include "Atmel.Vale.InsBasic.vaf"
include{:fstar}{:open} "Atmel.Machine_s"
include{:fstar}{:open} "Atmel.Vale.State"
include{:fstar}{:open} "Atmel.Vale.Decls"
include{:fstar}{:open} "Atmel.Vale.QuickCode"

module Atmel.Vale.InsMem

#verbatim{:interface}
open Defs_s
open Atmel.Machine_s
open Atmel.Vale.State
open Atmel.Vale.Decls
open Atmel.Vale.QuickCode
#endverbatim

#verbatim
open Atmel.Machine_s
open Atmel.Vale
open Atmel.Vale.State
open Atmel.Vale.StateLemmas
open Atmel.Vale.Decls
open Atmel.Vale.InsBasic
friend Atmel.Vale.Decls
module S = Atmel.Semantics_s
module P = Atmel.Print_s
#reset-options "--initial_fuel 2 --max_fuel 2 --z3rlimit 20"
#endverbatim

//procedure Mem64_in(in base:reg_opr8, inline offset:int) returns(o:operand)
//    {:public}
//    {:operand}
//    reads
//        mem;
//    extern;

//procedure Mem64_out(in base:reg_opr8, inline offset:int, in o:operand)
//    {:public}
//    {:operand}
//    modifies
//        mem;
//    extern;

//procedure Mem64_lemma(ghost base:operand, ghost offset:int)
//    {:public}
//    {:quick exportOnly}
//    {:typecheck false}
//    reads
//        mem;
//    requires
//        base is OReg;
//        valid_mem64(eval_operand(base, this) + offset, mem);
//    ensures
//        valid_operand(va_opr_code_Mem64(base, offset), this);
//{
//}

//procedure Load64(out dst:dst_opr8, in src:reg_opr8, inline offset:int)
//    {:public}
//    {:quick exportOnly}
//    reads
//        mem;
//    requires
//        valid_mem64(src + offset, mem);
//    ensures
//        dst == load_mem64(old(src + offset), mem);
//{
//    Mov64(dst, Mem64(src, offset));
//}

//procedure Store64(in dst:reg_opr8, in src:opr8, inline offset:int)
//    {:public}
//    {:quick exportOnly}
//    modifies
//        mem;
//    requires
//        valid_mem64(dst + offset, mem);
//    ensures
//        mem == old(store_mem64(dst + offset, src, mem));
//{
//    Mov64(Mem64(dst, offset), src);
//}

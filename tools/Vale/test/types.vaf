module Types

type byte:Type(0) := int_range(0, 0xff);
type nat32:Type(0) := int_range(0, 0xffff_ffff);
type list (a:Type(0)):Type(0) extern;
type fake_list (a:Type(0)):Type(0) extern;
type register:Type(0) extern;
type map(a:Type(0), b:Type(0)):Type(0) extern;
type seq(a:Type(0)):Type(0) extern;

function byte_test(x:byte, y:byte):byte extern;
function id #[a:Type(0)](x:a):a extern;
function nil #[a:Type(0)]():list(a) extern;
function cons #[a:Type(0)](hd:a, tl:list(a)):list(a) extern;
function operator(.field1) #[a:Type(0)](l:list(a)):bool extern;
function operator(.field1) #[a:Type(0)](l:fake_list(a)):int extern;

function l_not(x:prop):prop extern;
function l_and(x:prop, y:prop):prop extern;
function operator([]) #[a:Type(0), b:Type(0)](m:map(a, b), i:a):b extern;
function operator(?[]) #[a:Type(0), b:Type(0)](m:map(a, b), i:a):prop extern;
function operator([:=]) #[a:Type(0), b:Type(0)](m:map(a, b), i:a, v:b):map(a, b) extern;

const False:prop extern;

var{:state ok()} ok:bool;
var{:state reg(EAX)} eax:int;
var{:state reg(EBX)} ebx:int;
var{:state reg(ESP)} esp:int;

operand_type reg32:nat32 @ register:=
| inout eax
| inout ebx
;

operand_type mem32:nat32;
operand_type opr32:nat32 := reg32 | mem32 | in esp | const;

procedure{:typecheck} Expressions1(ghost x:int_range(10, 20)) returns(ghost y:int_range(15, 25))
{
    let a:bool := !true;
    let b:prop := !a;
    let c:prop := !b;
    let d:int := 5;
    let e:tuple(int, byte) := tuple(5, 5);
    let f:tuple(int, byte) := let z := tuple(5, 5) in z;
    let g:int_range((-20), (-10)) := (-x);
    let h:int_range((-20), (-10)) := let z := x in (-z);
    let i:int_range(13, 23) := x + 3;
    let j:int_range(7, 17) := x - 3;
    let k:int_range(30, 60) := x * 3;
    let l:int_range(30, 60) := x + 2 * x;
    let m:int_range(3, 6) := x / 3;
    let n:int_range(0, 2) := x % 3;
    let o:bool := a && a;
    let p:prop := a && b;
    let q:prop := b && a;
    let r:prop := b && b;
    let s:byte := if a then 10 else 20;
    let t := if a then 10 else 20;
    let u:byte := byte_test(x, byte_test(x, x));
    let v:byte := id(u);
    let w:tuple(byte, bool) := id(tuple(id(10), id(true)));
    let x := id#[byte](10);
    y := 20;
}

function ff(x1:byte, x2:byte, x3:byte, x4:byte):byte extern;

procedure{:typecheck} Expressions2(ghost x:int_range(10, 20), ghost fl:fake_list(int)) returns(ghost y:int_range(15, 25))
    requires x >= 15;
{
    let a:list(byte) := nil();
    let b := nil#[byte]();
    let c := cons(100, cons(200, b));
    let d:bool := c.field1;
    let e:int := fl.field1;
    let k:nat32 := id(5);
    let j:nat32 := (let m:byte := id#[byte](5) in m);
    let l:nat32 := id#[byte](5);
    y := #int_range(15, 20)(x);
    assert 7 < 8;
    if (3 < 3) {}
}

procedure{:typecheck} UopExpession(src: reg32) 
    reads eax;
{
    let a:int := old(eax);
    let b:register := @src;
    let c:prop := ~False;
}

procedure{:typecheck}{:testShouldFail} UopExpressionFail(src1: reg32, src2: opr32, inline src3: int)
    reads eax;
{
    let a:bool := old(eax);
    let s1:int := @src1;
    let s2 := @src2;
    let s3 := @src3;
    let b:bool := ~False;
    // TODO: UCustom: check f and f.alias have the same type?
}

procedure{:typecheck} BopExpression(ghost x:int, ghost m:map(int, int), ghost y: int_range(10, 20))
{
    let a:prop := x + 5 > 5 <==> x > 0;
    let b:prop := x > 0 ==> x + 5 > 5;
    let c:prop := x > 0 <== x + 5 > 5;  
    let d:bool := x = 5;
    let e:prop := x = 5;
    let f:bool := x == 5;
    let g:prop := x == 5;
    let h:bool := x != 5;
    let i:prop := x != 5;
    let j:bool := x > 5;
    let k:bool := (x >= 5) > (x -2);
    let l:prop := m?[x];
    let m:int := y + 3;
    let n:prop := x > 0 /\ x < y;
}

procedure{:typecheck}{:testShouldFail} BopExpressionFail(ghost x:int, ghost y: bool, ghost z: prop, ghost m:map(int, int), ghost ir:int_range(10, 20))
{
    let a:bool := x + 5 > 5 <==> x > 0;
    let b:prop := x + 5 > 5 <==> x + 5;
    let c:prop := x + 5 <==> x > 0;
    let d:bool := y || z;
    let e:bool := z && z;
    let d:bool := x = y;
    let f:bool := x > y;
    let g:bool := (x > 5) > y;
    let h:prop := m?[y];
    let i:prop := x?[x];
    let j:int := m?[5];
    let i:int := x + y;
    let i:int_range(10, 20) := x - 3;
    let j:int_range(8, 16) := ir - 3;
    let k:int_range(31, 59) := ir * 3;
    let l:int_range(31, 59) := ir + 2 * ir;
    let m:int_range(4, 6) := ir / 3;
    let n:int_range(1, 2) := ir % 3;
    let o:bool := x > 0 /\ x < y;
    let p:prop := x /\ x < 0;
    let q:prop := x > 0 /\ x;
}
procedure{:typecheck} OpExpression(ghost m:map(int, int), ghost i:int, ghost v:int)
{
  // TODO: FieldOp, FieldUpdate
  // CodeLemmaOp, RefineOp, StateOp, OperandArg
  let a:int := m[i];
  let b:map(int,int) := m[i:=v];
  let c:int_range(10, 20) := if i > 0 then 10 else 20;
}

procedure{:typecheck} OpExpressionFail(ghost m:map(int, int), ghost i:int, ghost v:int) 
{
    //let a:tuple(int, byte) := tuple(5, true);
    //let a:bool := m[i];
    //let b:int := m[true];
    //let c:int := i[i];
    //let d:map(int, bool) := m[i:=v];
    //let e:map(int, int) := m[i:=true];
    //let f:map(int, int) := m[true:=v];
    //let g:map(int, int) := i[i:=v];
    //let h := if i > 0 then 10 else true;
    //let j := if i then 10 else 20;
    //let k:bool := if i > 0 then 10 else 20;
}

procedure{:typecheck}{:testShouldFail} Fail()
{
    let a:int := 0;
    a := 1; // not mutable
}

procedure{:typecheck}{:testShouldFail} Fail()
{
    let d := nil(); // needs type annotation on d or type argument to nil
}

procedure{:typecheck}{:testShouldFail} Fail()
{
    let b:list(int) := nil#[bool]();
}

procedure{:typecheck}{:testShouldFail} Fail(ghost x:int_range(10, 20)) returns(ghost y:int_range(15, 25))
{
    let t := 10;
    y := t;
}

//This is now allowed:
//procedure{:typecheck}{:testShouldFail} Fail(ghost x:int_range(10, 20)) returns(ghost y:int_range(15, 25))
//    requires x >= 15;
//{
//    y := #int_range(15, 25)(x);
//}

// TODO: check that return values are assigned

procedure{:typecheck} Ghosts(ghost x:byte, ghost y:bool, inline z:byte)
{
}

procedure{:typecheck} Add(inout dst:opr32, src:opr32)
{
}

procedure{:typecheck} Statements(ghost x:byte, inline z:byte, o:reg32)
    reads esp;
    modifies eax; ebx;
{
    Ghosts(100, true, z);
    Add(eax, esp);
    Add(eax, id(id(5)));
    Add(eax, id(id(z)));
    Add(eax, id#[byte](id#[byte](5)) + 1);
    Add(eax, id(id(5)) + 1);
    Add(eax, 10);
    Add(eax, ebx);
    Add(eax, o);
}

procedure{:typecheck}{:testShouldFail} Fail(ghost x:byte, inline z:byte, o:reg32)
    reads esp;
    modifies eax; ebx;
{
    Add(o, eax);
}

procedure{:typecheck}{:testShouldFail} Fail(ghost x:byte)
    modifies eax; ebx; esp;
{
    Add(eax, id(id(x)));
}

procedure{:typecheck}{:testShouldFail} Fail()
    modifies eax; ebx; esp;
{
    Add(esp, eax);
}

procedure{:typecheck}{:testShouldFail} Fail(ghost x:byte, inline z:byte)
    modifies eax; ebx;
{
    Ghosts(100, true, x);
}

procedure{:typecheck}{:testShouldFail} Fail()
{
    let a:byte := byte_test(5);
}

procedure{:typecheck}{:testShouldFail} Fail()
{
    let a:byte := byte_test(200, 500);
}

procedure{:typecheck}{:testShouldFail} Fail(ghost x:int_range(10, 20)) returns(ghost y:int_range(15, 25))
{
    y := x;
}

procedure{:typecheck}{:testShouldFail} Fail()
{
    let a:bool := !5;
}

procedure{:typecheck}{:testShouldFail} Fail()
{
    let a:prop := !true;
    let b:bool := !a;
}

procedure{:typecheck}{:testShouldFail} Fail()
{
    let a:prop := !true;
    let b:bool := a && true;
}

procedure{:typecheck}{:testShouldFail} Fail(p:prop)
{
    let a:int := if p then 10 else 10;
}

procedure{:typecheck}{:testShouldFail} Fail()
{
    let e:tuple(int, byte) := tuple(5, 555);
}

procedure{:typecheck}{:testShouldFail} Fail()
{
    let y:bool := id(100);
}

function{:typecheck} f(x:int, y:int):int 
{
  x + y
}

function{:typecheck}{:testShouldFail} f(x:int, y:bool):int 
{
  x + y
}

function{:typecheck}{:testShouldFail} f(x:int, y:int):bool 
{
  x + y
}

function{:typecheck}{:testShouldFail} f(x:bool):bool
  requires x >= 0;
{
  x
}

//include "../../../fstar/code/arch/x64/X64.Vale.InsBasic.vaf"

module Test

var{:state ok()} ok:bool;

#verbatim{:interface}{:implementation}
open X64.Machine_s
open X64.Vale.Decls
open X64.Vale.InsBasic
#endverbatim

/* procedure p()
    modifies
        rax; efl;
    requires
        0 <= rax < 10 <= 11;
    ensures
        rax == old(rax) + 4;
{
    Add64Wrap(rax, 2);
    Add64Wrap(rax, 2);
}

#verbatim{:implementation}
let double (x:int):int = x + x
#endverbatim

function double (x:int):int extern;

procedure{:typecheck} Calls()
    requires
        rax < 7;
    modifies
        rax; rbx; efl;
    ensures
        rax == old(rax) + 7;
{
    Add64Wrap(rax, 1);
    ghost var z:int := rax;
    Mov64(rbx, #nat64(double(1)));
    assert rbx == 2;
    assert z == rax;
    if (rbx == 2)
    {
        Add64Wrap(rax, rbx);
        if (rbx == 3)
        {
            ghost var dummy := 2;
            Add64Wrap(rax, rbx);
            z := z + 2;
        }
        z := z + 2;
    }
    assert z == rax;
    p();
}

procedure Ghosts(ghost g1:int) returns(ghost g2:int)
    ensures
        g2 == g1 + 1;
{
    g2 := g1 + 1;
}
*/

procedure p #[#a : Type(0)]
  (ghost g1 : a) returns (ghost g2 : a)
{
  g2 := g1;
}

procedure p1 (ghost g1:int) returns(ghost g2:int)
{
  g2 := p(g1);
}

type{:primitive} list(a:Type(0)):Type(0) := Prims.list(a);
procedure List() /* returns (ghost l: list(bool)) */
{
  ghost var l := list(10, 20, 30);
  //ghost var ll:list(bool) := l;
}

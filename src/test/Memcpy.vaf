include "../arch/x64/X64.Vale.Decls.vaf"

#verbatim interface implementation
module Test.Memcpy
open X64.Machine_s
open X64.Vale.State_i
open X64.Vale.Decls
#set-options "--z3rlimit 20"
#endverbatim

//Should we strengthen the post condition when source and destination overlap?
procedure Memcpy(in register rsi:uint64, in register rdi:uint64, ghost len:uint64)
    requires/ensures
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> Map.contains(mem, rsi + i);
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> Map.contains(mem, rdi + i);
    ensures
        if (rsi + len < rdi) || (rdi + len < rsi) {
             forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> mem[rdi + i] == mem[rsi + i];
	     if (len % 8 != 0) {
	          // This is required because of memory is 8 byte aligned, always
	          mem[rsi + len/8] & ((1 << (len % 8)) - 1) = mem[rdi + len/8] & ((1 << (len % 8))-1);               
             }
	} 
	          
    reads
        rsi; rdi;
    modifies
        mem;
{

}


procedure Memmove(in register rsi:uint64, in register rdi:uint64, ghost len:uint64)
    requires/ensures
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> Map.contains(mem, rsi + i);
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> Map.contains(mem, rdi + i);
    ensures
        // source operand is not changed
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> mem[rsi + i] == old(mem)[rsi + i]; 
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> mem[rdi + i] == mem[rsi + i];
         if (len % 8 != 0) {
	     mem[rsi + len/8] & ((1 << (len % 8)) - 1) = mem[rdi + len/8] & ((1 << (len % 8))-1);               
         }
    reads
        rsi; rdi;
    modifies
        mem;
{

}
include "../arch/x64/X64.Vale.Decls.vaf"

#verbatim interface implementation
module Test.Memcpy
open X64.Machine_s
open X64.Vale.State_i
open X64.Vale.Decls
#set-options "--z3rlimit 20"
#endverbatim

procedure Memcpy(in register rsi:uint64, out register rdi:uint64, ghost len:uint64)
    requires/ensures
        rsi + 64 <= rdi;
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> Map.contains(mem, rsi + i);
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> Map.contains(mem, rdi + i);
    ensures
        if (rsi + len < rdi) || (rdi + len < rsi) {
             forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> mem[rdi + i] == mem[rsi + i];
	     if (len % 8 != 0) {
	          mem[rsi + len/8] & ((1 << (len % 8)) - 1) = mem[rdi + len/8] & ((1 << (len % 8))-1);               
             }
	} 
	          
    reads
        rsi; rdi;
    modifies
        rax; rbx; rcx; rdx; rbp;
        mem;
{

}


procedure Memmove(in register rsi:uint64, out register rdi:uint64, ghost len:uint64)
    requires/ensures
        rsi + 64 <= rdi;
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> Map.contains(mem, rsi + i);
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> Map.contains(mem, rdi + i);
    ensures
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> mem[rdi + i] == mem[rsi + i];
	if (len % 8 != 0) {
	     mem[rsi + len/8] & ((1 << (len % 8)) - 1) = mem[rdi + len/8] & ((1 << (len % 8))-1);               
         }
    reads
        rsi; rdi;
    modifies
        rax; rbx; rcx; rdx; rbp;
        mem;
{

}
include "../arch/x64/X64.Vale.Decls.vaf"

#verbatim interface implementation
module Test.Memcpy
open X64.Machine_s
open X64.Vale.State_i
open X64.Vale.Decls
#set-options "--z3rlimit 20"
#endverbatim

//Should we strengthen the post condition when source and destination overlap?
procedure Memcpy(in register rsi:uint64, in register rdi:uint64, len:uint64)
    requires/ensures
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> Map.contains(mem, rsi + i);
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> Map.contains(mem, rdi + i);
    ensures
        if (rsi + len < rdi) || (rdi + len < rsi) {
             forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> mem[rdi + i] == mem[rsi + i];
	     if (len % 8 != 0) {
	          // This is required because memory is 8 byte aligned, always
	          mem[rsi + len/8] & ((1 << (len % 8)) - 1) = mem[rdi + len/8] & ((1 << (len % 8))-1);               
             }
	} 
	          
    reads
        rsi; rdi;
    modifies
        mem;
{
    Load(rax, rsi, 0);
    Store(rdi, rax, 0);
    Load(rbx, rsi, 4);
    Store(rdi, rbx, 4);
    Load(rcx, rsi, 8);
    Store(rdi, rcx, 8);
    Load(rdx, rsi, 12);
    Store(rdi, rdx, 11);
    Load(rbp, rsi, 16);
    Store(rdi, rbp, 16);
}


procedure Memmove(in register rsi:uint64, in register rdi:uint64, len:uint64)
    requires/ensures
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> Map.contains(mem, rsi + i);
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> Map.contains(mem, rdi + i);
    ensures
        // source operand is not changed
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> mem[rsi + i] == old(mem)[rsi + i]; 
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> mem[rdi + i] == mem[rsi + i];
         if (len % 8 != 0) {
	     mem[rsi + len/8] & ((1 << (len % 8)) - 1) = mem[rdi + len/8] & ((1 << (len % 8))-1);               
         }
    reads
        rsi; rdi;
    modifies
        mem;
{

}

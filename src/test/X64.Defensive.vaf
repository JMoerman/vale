include "../arch/x64/X64.Vale.Decls.vaf"

#verbatim interface implementation
module Test
open X64.Machine_s
open X64.Vale.State_i
open X64.Vale.Decls
open Manifest
#set-options "--z3rlimit 20"

let is_inside_u_region (addr:uint64) (u:memlayout) = ( addr < get_u_start + get_u_size) /\ ( addr > = get_u_start)  
#endverbatim

#token &= precedence :=
#token >>= precedence :=
#token <<= precedence :=
#token += precedence :=

procedure operator(&=) (inout operand dst:uint64, operand src:uint64) := And64;
procedure operator(>>=) (inout operand dst:uint64, operand src:uint64) := Shr64;
procedure operator(<<=) (inout operand dst:uint64, operand src:uint64) := Shl64;
procedure operator(:=) (out operand dst:int, operand src:int) := Mov64;
procedure operator(+=) (inout operand dst:int, operand src:int) := Add64;


procedure SafeWrite(register dst:uint64, register src:uint64, inline offset:uint64,  ghost u:umemlayout)
      requires
         true;
      modifies
         mem; efl; r8; rdx; rcx; rax;
      ensures
       is_inside_u_region (dst, offset, u);
       mem[dst + offset] != old(mem)[dst + offset] ==> And64(mem[bitmap_address + Shl64(Shr64((dst + offset), 9), 3)], Shr64(Shl64(1, (dst + offset)), 3)) == 1;
{
       ghost var bitmap_address:uint64 := get_bitmap_start(u);
      // var u_addr_mask:uint64 :=0xFFFFFFFFE0000000; 
       Mov64(r8, dst);
       Add64(r8, offset);
       Mov64(rax, r8);
       And64(rax, 0xFFFFFFFFE0000000);
       Xor64(rax, 0x20000000);
       if (zf(efl) == 1){  
            Mov64(rdx, bitmap_address);
            Mov64(rcx, r8);
            Shr64(rcx, 9);
            Mov64(rax, r8);
            Shr64(rax, 3);
            Load64(rcx, rdx, rcx*8); 
            Bt64(rcx, rax);  
            if ( cf(efl) == 1){
               Store64(dst, src, offset);
            } else{
               assume false;
            }
        } else {
           assume false;
        }
}

include "../arch/x64/X64.Vale.Decls.vaf"

#verbatim interface implementation
module X64.Defensive 
open X64.Machine_s
open X64.Vale.State_i
open X64.Vale.Decls
open Manifest
#set-options "--z3rlimit 20"

#endverbatim

#token &= precedence :=
#token >>= precedence :=
#token <<= precedence :=
#token += precedence :=

procedure operator(&=) (inout operand dst:uint64, operand src:uint64) := And64;
procedure operator(>>=) (inout operand dst:uint64, operand src:uint64) := Shr64;
procedure operator(<<=) (inout operand dst:uint64, operand src:uint64) := Shl64;
procedure operator(:=) (out operand dst:int, operand src:int) := Mov64;
procedure operator(+=) (inout operand dst:int, operand src:int) := Add64;

procedure SafeWrite(register dst:uint64, register src:uint64, inline offset:uint64,  ghost u:umemlayout)
      requires
         true;
      modifies
         mem; efl; r8; rdx; rcx; rax;
      ensures
       is_inside_u_region (dst, offset, u);
       mem[dst + offset] != old(mem)[dst + offset] ==> And64(mem[bitmap_address + Shl64(Shr64((dst + offset), 9), 3)], Shr64(Shl64(1, (dst + offset)), 3)) == 1;
{
       //ghost var bitmap_address:uint64 := get_bitmap_start(u);
      // var u_addr_mask:uint64 :=0xFFFFFFFFE0000000; 
       Mov64(r8, dst);
       Add64(r8, offset);
       Mov64(rax, r8);
       And64(rax, 0xFFFFFFFFE0000000);
       Xor64(rax, 0x20000000);
       if ( zf(efl) ) {  
            Mov64(rdx, const(get_bitmap_start(u)));
            Mov64(rcx, r8);
            Shr64(rcx, 9);
            Mov64(rax, r8);
            Shr64(rax, 3);
            IMul64(rcx, 8);
            Add64(rdx, rcx);
            Load64(rcx, rdx, 0); 
            Bt64(rcx, rax);
        } else {
            assume false;
        }
        if ( cf(efl) ){
               Store64(dst, src, offset);
        } else{
               assume false;
        }
       
}

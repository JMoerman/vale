include "../arch/x64/X64.Vale.Decls.vaf"

#verbatim interface implementation
module Test.Memcpy
module M = Memory_i_s
open X64.Machine_s
open X64.Vale.State_i
open X64.Vale.Decls
//open X64.Vale.StrongPost_i
#set-options "--z3rlimit 20"
#endverbatim

procedure Copy16(ghost bsrc:buffer64, ghost bdst:buffer64)
    requires/ensures
        locs_disjoint(list(loc_buffer(bsrc), loc_buffer(bdst)));
        buffer_readable(mem, bsrc);
        buffer_readable(mem, bdst);
        buffer_length(bsrc) == 2;
        buffer_length(bdst) == 2;
        rsi == buffer_addr(bsrc);
        rdi == buffer_addr(bdst);
    ensures
        forall i :: 0 <= i && i < 2 ==> buffer64_read(bdst, i, mem) == buffer64_read(bsrc, i, mem);
        modifies_buffer(bdst, old(mem), mem);
    reads
        rsi; rdi;
    modifies
        rax; rbx;
        mem;
{
//    assert{:fast_block} true;
    Load64_buffer(rax, rsi, 0, bsrc, 0);
    Load64_buffer(rbx, rsi, 8, bsrc, 1);
    Store64_buffer(rdi, rax, 0, bdst, 0);
    Store64_buffer(rdi, rbx, 8, bdst, 1);
}

#verbatim interface
let validSrcAddrs64 (m:mem) (addr:int) (b:buffer64) (len:int) =
    //(buffer_readable m b \/ buffer_length b == 0) /\        // Buffer library's modifies clause treats 0-length buffers specially
    buffer_readable m b /\
    len <= buffer_length b /\
    buffer_addr b == addr

// TODO: This is dangerous, as it precludes changes to any other buffer    
let modifies_buffer_specific (b:buffer64) (h1 h2:mem) (start last:nat) : GTot Type0 =
    modifies_buffer b h1 h2 /\
    // TODO: Consider replacing this with: modifies (loc_buffer (gsub_buffer b i len)) h1 h2
    (forall (i:nat) . {:pattern (buffer64_read b i h2)}
                        0 <= i /\ i < buffer_length b 
                     /\ (i < start || i > last) 
                    ==> buffer64_read b i h1
                     == buffer64_read b i h2)

unfold let buffers_disjoint (b1 b2:buffer64) =
    locs_disjoint [loc_buffer b1; loc_buffer b2]
#endverbatim

#verbatim
#reset-options "--max_fuel 2 --initial_fuel 2"
#endverbatim

// PROBLEM 1:
procedure ValidityPreservationFail(ghost bsrc:buffer64, ghost bdst:buffer64, ghost len:int)
    requires/ensures
        buffers_disjoint(bsrc, bdst);
        validSrcAddrs64(mem, rsi, bsrc, len);
        validSrcAddrs64(mem, rdi, bdst, 2);
    reads
        rsi; rdi;
    modifies
        rax; rbx;
        mem;
{
    Store64_buffer(rdi, rax, 0, bdst, 0);
    // Without the following, plus extra fuel above, post-condition fails on: validSrcAddrs64(mem, rsi, bsrc, len);
    assert buffers_readable(mem, list(bdst));   // OBSERVE
}

// Restore fuel settings to defaults
#verbatim
#reset-options 
#endverbatim


procedure Modifier(ghost b:buffer64)
    requires/ensures 
        validSrcAddrs64(mem, rdi, b, 10);
    reads
        rdi; 
    modifies
        mem;
    ensures
        modifies_buffer_specific(b, old(mem), mem, 0, 5);
{
}

// PROBLEM 2:
procedure ValuePreservationFail(ghost bsrc:buffer64, ghost bdst:buffer64, ghost len:int)
    requires
        buffers_disjoint(bsrc, bdst);
        //validSrcAddrs64(mem, rsi, bsrc, len);
        validSrcAddrs64(mem, rdi, bdst, 10);
    reads
        rsi; rdi;
    modifies
        rax; rbx;
        mem;
{
    Store64_buffer(rdi, rax, 48, bdst, 6);
    Modifier(bdst);
    // Without the following, final assertion fails.  
    // Have to mention modifies_buffer_specific's here, before another Store64_buffer
    assert buffer64_read(bdst, 6, mem) == rax;        // OBSERVE
    Store64_buffer(rdi, rax, 0, bdst, 0);
    Load64_buffer(rbx, rdi, 48, bdst, 6);
    assert rbx == rax;
}

/*
procedure Copy64()
    requires/ensures
        rsi + 64 <= rdi;
        forall i {Map.contains(mem, i)}:: rsi <= i < rsi + 64 && (i - rsi) % 8 == 0 ==> Map.contains(mem, i);
        forall i {Map.contains(mem, i)}:: rdi <= i < rdi + 64 && (i - rdi) % 8 == 0 ==> Map.contains(mem, i);
    ensures
        forall i :: 0 <= i && i < 64 && i % 8 == 0 ==> mem[rdi + i] == mem[rsi + i];
    reads
        rsi; rdi;
    modifies
        rax; rbx; rcx; rdx; rbp;
        mem;
{
    assert{:fast_block} true;
    Load64(rax, rsi, 0);
    Load64(rbx, rsi, 8);
    Load64(rcx, rsi, 16);
    Load64(rdx, rsi, 24);
    Load64(rbp, rsi, 32);
    Store64(rdi, rax, 0);
    Store64(rdi, rbx, 8);
    Store64(rdi, rcx, 16);
    Store64(rdi, rdx, 24);
    Store64(rdi, rbp, 32);
    Load64(rax, rsi, 40);
    Load64(rbx, rsi, 48);
    Load64(rcx, rsi, 56);
    Store64(rdi, rax, 40);
    Store64(rdi, rbx, 48);
    Store64(rdi, rcx, 56);
}

procedure Copy128()
    requires/ensures
        rsi + 128 <= rdi;
        forall i {Map.contains(mem, i)}:: rsi <= i < rsi + 128 && (i - rsi) % 8 == 0 ==> Map.contains(mem, i);
        forall i {Map.contains(mem, i)}:: rdi <= i < rdi + 128 && (i - rdi) % 8 == 0 ==> Map.contains(mem, i);
    ensures
        forall i :: 0 <= i && i < 128 && i % 8 == 0 ==> mem[rdi + i] == mem[rsi + i];
    reads
        rsi; rdi;
    modifies
        rax; rbx; rcx; rdx; rbp;
        mem;
{
    assert{:fast_block} true;
    Load64(rax, rsi, 0);
    Load64(rbx, rsi, 8);
    Load64(rcx, rsi, 16);
    Load64(rdx, rsi, 24);
    Load64(rbp, rsi, 32);
    Store64(rdi, rax, 0);
    Store64(rdi, rbx, 8);
    Store64(rdi, rcx, 16);
    Store64(rdi, rdx, 24);
    Store64(rdi, rbp, 32);
    Load64(rax, rsi, 40);
    Load64(rbx, rsi, 48);
    Load64(rcx, rsi, 56);
    Load64(rdx, rsi, 64);
    Load64(rbp, rsi, 72);
    Store64(rdi, rax, 40);
    Store64(rdi, rbx, 48);
    Store64(rdi, rcx, 56);
    Store64(rdi, rdx, 64);
    Store64(rdi, rbp, 72);
    Load64(rax, rsi, 80);
    Load64(rbx, rsi, 88);
    Load64(rcx, rsi, 96);
    Load64(rdx, rsi, 104);
    Load64(rbp, rsi, 112);
    Store64(rdi, rax, 80);
    Store64(rdi, rbx, 88);
    Store64(rdi, rcx, 96);
    Store64(rdi, rdx, 104);
    Store64(rdi, rbp, 112);
    Load64(rax, rsi, 120);
    Store64(rdi, rax, 120);
}
*/

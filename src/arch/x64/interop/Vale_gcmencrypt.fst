module Vale_gcmencrypt

open Opaque_s
open FStar.Seq
open Words_s
open Words.Seq_s
open Types_s
open Types_i
open AES_s
open GCTR_s
open GCTR_i
open GCM_i
open GHash_s
open GHash_i
open GCM_s
open X64.AES
open GF128_s
open GF128_i
open X64.Poly1305.Math_i
open GCM_helpers_i
open X64.GHash
open X64.GCTR
open X64.Machine_s
open X64.Memory_i
open X64.Vale.State_i
open X64.Vale.Decls_i
open X64.Vale.InsBasic
open X64.Vale.InsMem
open X64.Vale.InsVector
open X64.Vale.InsAes
open X64.Vale.QuickCode_i
open X64.Vale.QuickCodes_i
open X64.GF128_Mul
open X64.GCMencrypt

val va_code_gcmencrypt: unit -> va_code
let va_code_gcmencrypt () = va_code_gcm_encrypt2_stdcall true AES_128


let vale_pre (va_b0:va_code) (va_s0:va_state) (win:bool) (alg:algorithm) (iv_BE:quad32)
  (plain_b:buffer128) (plain_num_bytes:nat64) (auth_b:buffer128) (auth_num_bytes:nat64) (iv_b:buffer128) (out_b:buffer128)    
  (tag_b:buffer128) (stack_b:buffer64) (key:(aes_key_LE alg)) (round_keys:(seq quad32))
  (keys_b:buffer128) =
((va_require_total va_b0 (va_code_gcm_encrypt2_stdcall win alg) va_s0) /\ (va_get_ok
    va_s0) /\ (let plain_ptr = (if win then (va_get_reg Rcx va_s0) else (va_get_reg Rdi va_s0)) in
    let auth_ptr = (if win then (va_get_reg R8 va_s0) else (va_get_reg Rdx va_s0)) in let iv_ptr =
    (if win then (buffer64_read stack_b (18 + 4 + 1 + 0) (va_get_mem va_s0)) else (va_get_reg R8
    va_s0)) in let expanded_key_ptr = (if win then (buffer64_read stack_b (18 + 4 + 1 + 1)
    (va_get_mem va_s0)) else (va_get_reg R9 va_s0)) in let out_ptr = (if win then (buffer64_read
    stack_b (18 + 4 + 1 + 2) (va_get_mem va_s0)) else (buffer64_read stack_b (8 + 0) (va_get_mem
    va_s0))) in let tag_ptr = (if win then (buffer64_read stack_b (18 + 4 + 1 + 3) (va_get_mem
    va_s0)) else (buffer64_read stack_b (8 + 1) (va_get_mem va_s0))) in (buffers_disjoint128
    plain_b out_b) /\ (buffers_disjoint128 auth_b out_b) /\ (buffers_disjoint128 keys_b out_b) /\
    (buffers_disjoint128 out_b tag_b) /\ (locs_disjoint [(loc_buffer stack_b); (loc_buffer
    plain_b)]) /\ (locs_disjoint [(loc_buffer stack_b); (loc_buffer auth_b)]) /\ (locs_disjoint
    [(loc_buffer stack_b); (loc_buffer iv_b)]) /\ (locs_disjoint [(loc_buffer stack_b); (loc_buffer
    out_b)]) /\ (locs_disjoint [(loc_buffer stack_b); (loc_buffer tag_b)]) /\ (locs_disjoint
    [(loc_buffer stack_b); (loc_buffer keys_b)]) /\ plain_num_bytes == (if win then (va_get_reg Rdx
    va_s0) else (va_get_reg Rsi va_s0)) /\ auth_num_bytes == (if win then (va_get_reg R9 va_s0)
    else (va_get_reg Rcx va_s0)) 
    /\ (validSrcAddrs128 (va_get_mem va_s0) plain_ptr plain_b
    (bytes_to_quad_size plain_num_bytes)) /\ (validSrcAddrs128 (va_get_mem va_s0) auth_ptr auth_b
    (bytes_to_quad_size auth_num_bytes)) /\ (validSrcAddrs128 (va_get_mem va_s0) iv_ptr iv_b 1) 
    /\
    (validDstAddrs128 (va_get_mem va_s0) out_ptr out_b (bytes_to_quad_size plain_num_bytes)) /\
    (validDstAddrs128 (va_get_mem va_s0) tag_ptr tag_b 1)
    /\ 
    (buffer_length stack_b) >= (if win then  (4 + 1 + 4 + 18) else (2 + 8)) /\ 
    (valid_stack_slots (va_get_mem va_s0) (va_get_reg Rsp va_s0) stack_b (if win then 18 else 8)) 
    /\ plain_ptr + 16 `op_Multiply` (bytes_to_quad_size
    plain_num_bytes) < pow2_64 /\ auth_ptr + 16 `op_Multiply` (bytes_to_quad_size auth_num_bytes) <
    pow2_64 /\ out_ptr + 16 `op_Multiply` (bytes_to_quad_size plain_num_bytes) < pow2_64 /\
    (buffer_length plain_b) == (buffer_length out_b) /\ (buffer_length out_b) ==
    (bytes_to_quad_size plain_num_bytes) /\ (buffer_length auth_b) == (bytes_to_quad_size
    auth_num_bytes) /\ 256 `op_Multiply` (buffer_length plain_b) < pow2_32 /\ 4096 `op_Multiply`
    plain_num_bytes < pow2_32 /\ 4096 `op_Multiply` auth_num_bytes < pow2_32 /\ iv_BE ==
    (reverse_bytes_quad32 (buffer128_read iv_b 0 (va_get_mem va_s0))) /\ 256 `op_Multiply`
    (bytes_to_quad_size auth_num_bytes) < pow2_32 /\ 256 `op_Multiply` (bytes_to_quad_size
    plain_num_bytes) < pow2_32 /\ (alg = AES_128 || alg = AES_256) 
    /\ (length round_keys) == (nr alg) + 1 /\ round_keys == (key_to_round_keys_LE alg key) 
    /\ (validSrcAddrs128 (va_get_mem va_s0) expanded_key_ptr keys_b ((nr alg) + 1))
    /\ (buffer128_as_seq (va_get_mem va_s0) keys_b) == round_keys))

//TODO: Fill this
  //va_pre and va_post should correspond to the pre- and postconditions generated by Vale
let va_pre (va_b0:va_code) (va_s0:va_state)
(plain_b:buffer128) (plain_num_bytes:nat64) (auth_b:buffer128) (auth_num_bytes:nat64) (iv_b:buffer128) (key:(aes_key_LE AES_128)) (keys_b:buffer128) (cipher_b:buffer128) (tag_b:buffer128) (stack_b:buffer64)  =
  let iv_BE = reverse_bytes_quad32 (buffer128_read iv_b 0 (va_get_mem va_s0)) in
  let round_keys = key_to_round_keys_LE AES_128 key in
  vale_pre va_b0 va_s0 true AES_128 iv_BE plain_b plain_num_bytes auth_b auth_num_bytes iv_b 
    cipher_b tag_b stack_b key round_keys keys_b

let vale_post (va_b0:va_code) (va_s0:va_state) (win:bool) (alg:algorithm) (iv_BE:quad32)
  (plain_b:buffer128) (plain_num_bytes:nat64) (auth_b:buffer128) (auth_num_bytes:nat64) (iv_b:buffer128) (out_b:buffer128)    
  (tag_b:buffer128) (stack_b:buffer64) (key:(aes_key_LE alg))
  (keys_b:buffer128) (va_sM:va_state) (va_fM:va_fuel) =
((va_ensure_total va_b0 va_s0 va_sM va_fM) /\ (va_get_ok va_sM)
    /\ (let plain_ptr = (if win then (va_get_reg Rcx va_s0) else (va_get_reg Rdi va_s0)) in let
    auth_ptr = (if win then (va_get_reg R8 va_s0) else (va_get_reg Rdx va_s0)) in let iv_ptr = (if
    win then (buffer64_read stack_b (18 + 4 + 1 + 0) (va_get_mem va_s0)) else (va_get_reg R8
    va_s0)) in let expanded_key_ptr = (if win then (buffer64_read stack_b (18 + 4 + 1 + 1)
    (va_get_mem va_s0)) else (va_get_reg R9 va_s0)) in let out_ptr = (if win then (buffer64_read
    stack_b (18 + 4 + 1 + 2) (va_get_mem va_s0)) else (buffer64_read stack_b (8 + 0) (va_get_mem
    va_s0))) in let tag_ptr = (if win then (buffer64_read stack_b (18 + 4 + 1 + 3) (va_get_mem
    va_s0)) else (buffer64_read stack_b (8 + 1) (va_get_mem va_s0))) in (modifies_mem (loc_union
    (loc_union (loc_buffer stack_b) (loc_buffer out_b)) (loc_buffer tag_b)) (va_get_mem va_s0)
    (va_get_mem va_sM)) /\ (validSrcAddrs128 (va_get_mem va_sM) out_ptr out_b (bytes_to_quad_size
    plain_num_bytes)) /\ (validSrcAddrs128 (va_get_mem va_sM) tag_ptr tag_b 1) /\ (let auth =
    (slice_work_around (le_seq_quad32_to_bytes (buffer128_as_seq (va_get_mem va_s0) auth_b))
    auth_num_bytes) in let plain = (slice_work_around (le_seq_quad32_to_bytes (buffer128_as_seq
    (va_get_mem va_s0) plain_b)) plain_num_bytes) in let cipher = (slice_work_around
    (le_seq_quad32_to_bytes (buffer128_as_seq (va_get_mem va_sM) out_b)) plain_num_bytes) in (l_and
    (l_and (l_and (4096 `op_Multiply` (length plain) < pow2_32) (4096 `op_Multiply` (length auth) <
    pow2_32)) (cipher == (fst (gcm_encrypt_LE alg (seq_nat32_to_seq_nat8_LE key)
    (be_quad32_to_bytes iv_BE) plain auth)))) ((le_quad32_to_bytes (buffer128_read tag_b 0
    (va_get_mem va_sM))) == (snd (gcm_encrypt_LE alg (seq_nat32_to_seq_nat8_LE key)
    (be_quad32_to_bytes iv_BE) plain auth)))) /\ (va_get_reg Rsp va_sM) == (va_get_reg Rsp va_s0)
    /\ (win ==> (va_get_reg Rbx va_sM) == (va_get_reg Rbx va_s0)) /\ (win ==> (va_get_reg Rbp
    va_sM) == (va_get_reg Rbp va_s0)) /\ (win ==> (va_get_reg Rdi va_sM) == (va_get_reg Rdi va_s0))
    /\ (win ==> (va_get_reg Rsi va_sM) == (va_get_reg Rsi va_s0)) /\ (win ==> (va_get_reg R12
    va_sM) == (va_get_reg R12 va_s0)) /\ (win ==> (va_get_reg R13 va_sM) == (va_get_reg R13 va_s0))
    /\ (win ==> (va_get_reg R14 va_sM) == (va_get_reg R14 va_s0)) /\ (win ==> (va_get_reg R15
    va_sM) == (va_get_reg R15 va_s0)) /\ (win ==> (va_get_xmm 6 va_sM) == (va_get_xmm 6 va_s0)) /\
    (win ==> (va_get_xmm 7 va_sM) == (va_get_xmm 7 va_s0)) /\ (win ==> (va_get_xmm 8 va_sM) ==
    (va_get_xmm 8 va_s0)) /\ (win ==> (va_get_xmm 9 va_sM) == (va_get_xmm 9 va_s0)) /\ (win ==>
    (va_get_xmm 10 va_sM) == (va_get_xmm 10 va_s0)) /\ (win ==> (va_get_xmm 11 va_sM) ==
    (va_get_xmm 11 va_s0)) /\ (win ==> (va_get_xmm 12 va_sM) == (va_get_xmm 12 va_s0)) /\ (win ==>
    (va_get_xmm 13 va_sM) == (va_get_xmm 13 va_s0)) /\ (win ==> (va_get_xmm 14 va_sM) ==
    (va_get_xmm 14 va_s0)) /\ (win ==> (va_get_xmm 15 va_sM) == (va_get_xmm 15 va_s0)) /\ (~win ==>
    (va_get_reg Rbx va_sM) == (va_get_reg Rbx va_s0)) /\ (~win ==> (va_get_reg Rbp va_sM) ==
    (va_get_reg Rbp va_s0)) /\ (~win ==> (va_get_reg R12 va_sM) == (va_get_reg R12 va_s0)) /\ (~win
    ==> (va_get_reg R13 va_sM) == (va_get_reg R13 va_s0)) /\ (~win ==> (va_get_reg R14 va_sM) ==
    (va_get_reg R14 va_s0)) /\ (~win ==> (va_get_reg R15 va_sM) == (va_get_reg R15 va_s0)))) /\
    (va_state_eq va_sM (va_update_reg Rsp va_sM (va_update_flags va_sM (va_update_mem va_sM
    (va_update_reg Rsi va_sM (va_update_reg Rdi va_sM (va_update_reg Rbp va_sM (va_update_xmm 15
    va_sM (va_update_xmm 14 va_sM (va_update_xmm 13 va_sM (va_update_xmm 12 va_sM (va_update_xmm 11
    va_sM (va_update_xmm 10 va_sM (va_update_xmm 9 va_sM (va_update_xmm 8 va_sM (va_update_xmm 7
    va_sM (va_update_xmm 6 va_sM (va_update_xmm 5 va_sM (va_update_xmm 4 va_sM (va_update_xmm 3
    va_sM (va_update_xmm 2 va_sM (va_update_xmm 1 va_sM (va_update_xmm 0 va_sM (va_update_reg R15
    va_sM (va_update_reg R14 va_sM (va_update_reg R13 va_sM (va_update_reg R12 va_sM (va_update_reg
    R11 va_sM (va_update_reg R10 va_sM (va_update_reg R9 va_sM (va_update_reg R8 va_sM
    (va_update_reg Rdx va_sM (va_update_reg Rcx va_sM (va_update_reg Rbx va_sM (va_update_reg Rax
    va_sM (va_update_ok va_sM va_s0)))))))))))))))))))))))))))))))))))))

let va_post (va_b0:va_code) (va_s0:va_state) (va_sM:va_state) (va_fM:va_fuel)
  (plain_b:buffer128) (plain_num_bytes:nat64) (auth_b:buffer128) (auth_num_bytes:nat64) (iv_b:buffer128) (key:(aes_key_LE AES_128)) (keys_b:buffer128) (cipher_b:buffer128) (tag_b:buffer128) (stack_b:buffer64) =
    let iv_BE = reverse_bytes_quad32 (buffer128_read iv_b 0 (va_get_mem va_s0)) in
    vale_post va_b0 va_s0 true AES_128 iv_BE plain_b plain_num_bytes auth_b auth_num_bytes
     iv_b cipher_b tag_b stack_b key keys_b va_sM va_fM
  
val va_lemma_gcmencrypt(va_b0:va_code) (va_s0:va_state)
  (plain_b:buffer128) (plain_num_bytes:nat64) (auth_b:buffer128) (auth_num_bytes:nat64) (iv_b:buffer128) (key:(aes_key_LE AES_128)) (keys_b:buffer128) (cipher_b:buffer128) (tag_b:buffer128) (stack_b:buffer64) : Ghost ((va_sM:va_state) * (va_fM:va_fuel))
  (requires va_pre va_b0 va_s0 plain_b plain_num_bytes auth_b auth_num_bytes iv_b key keys_b cipher_b tag_b stack_b)
  (ensures (fun (va_sM, va_fM) -> va_post va_b0 va_s0 va_sM va_fM plain_b plain_num_bytes auth_b auth_num_bytes iv_b key keys_b cipher_b tag_b stack_b))

let va_lemma_gcmencrypt va_b0 va_s0 plain_b plain_num_bytes auth_b auth_num_bytes iv_b key keys_b cipher_b tag_b stack_b = 
  let iv_BE = reverse_bytes_quad32 (buffer128_read iv_b 0 (va_get_mem va_s0)) in
  let round_keys = key_to_round_keys_LE AES_128 key in  
  va_lemma_gcm_encrypt2_stdcall va_b0 va_s0 true AES_128 iv_BE plain_b plain_num_bytes auth_b
    auth_num_bytes iv_b cipher_b tag_b stack_b key round_keys keys_b

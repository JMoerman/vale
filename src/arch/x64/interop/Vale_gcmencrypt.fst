module Vale_gcmencrypt

open X64.Machine_s
open X64.Memory_i
open X64.Vale.State_i
open X64.Vale.Decls_i
open AES_s

val va_code_gcmencrypt: unit -> va_code
let va_code_gcmencrypt () = admit()


//TODO: Fill this
  //va_pre and va_post should correspond to the pre- and postconditions generated by Vale
let va_pre (va_b0:va_code) (va_s0:va_state)
(plain_b:buffer128) (plain_num_bytes:nat64) (auth_b:buffer128) (auth_num_bytes:nat64) (iv_b:buffer128) (key:(aes_key_LE AES_128)) (keys_b:buffer128) (cipher_b:buffer128) (tag_b:buffer128)  = True


let va_post (va_b0:va_code) (va_s0:va_state) (va_sM:va_state) (va_fM:va_fuel)
  (plain_b:buffer128) (plain_num_bytes:nat64) (auth_b:buffer128) (auth_num_bytes:nat64) (iv_b:buffer128) (key:(aes_key_LE AES_128)) (keys_b:buffer128) (cipher_b:buffer128) (tag_b:buffer128)  =
    buffer_readable va_s0.mem plain_b /\ buffer_readable va_s0.mem auth_b /\ buffer_readable va_s0.mem keys_b
    /\ buffer_readable va_s0.mem iv_b  /\ buffer_readable va_s0.mem tag_b /\ buffer_readable va_s0.mem cipher_b /\
    buffer_readable va_sM.mem plain_b /\ buffer_readable va_sM.mem auth_b /\ buffer_readable va_sM.mem keys_b
    /\ buffer_readable va_sM.mem iv_b  /\ buffer_readable va_sM.mem tag_b /\ buffer_readable va_sM.mem cipher_b
    /\ va_sM.ok /\ va_s0 == va_sM /\
    va_ensure_total (va_code_gcmencrypt()) va_s0 va_sM va_fM

val va_lemma_gcmencrypt(va_b0:va_code) (va_s0:va_state)
  (plain_b:buffer128) (plain_num_bytes:nat64) (auth_b:buffer128) (auth_num_bytes:nat64) (iv_b:buffer128) (key:(aes_key_LE AES_128)) (keys_b:buffer128) (cipher_b:buffer128) (tag_b:buffer128) : Ghost ((va_sM:va_state) * (va_fM:va_fuel))
  (requires va_pre va_b0 va_s0 plain_b plain_num_bytes auth_b auth_num_bytes iv_b key keys_b cipher_b tag_b )
  (ensures (fun (va_sM, va_fM) -> va_post va_b0 va_s0 va_sM va_fM plain_b plain_num_bytes auth_b auth_num_bytes iv_b key keys_b cipher_b tag_b ))

let va_lemma_gcmencrypt va_b0 va_s0 plain_b plain_num_bytes auth_b auth_num_bytes iv_b keys_b cipher_b tag_b = admit()

module Vale_aes

open Types_s
open Types_i
open FStar.Seq
open X64.Machine_s
open X64.Memory_i
open X64.Vale.State_i
open X64.Vale.Decls_i
open AES_s
open AES_helpers_i
open X64.AES

val va_code_aes: unit -> va_code

let va_code_aes = fun () -> va_code_KeyExpansionStdcall false

//TODO: Fill this
// va_pre and va_post should correspond to the pre- and postconditions generated by Vale
let va_pre (va_b0:va_code) (va_s0:va_state)
(input_key:buffer128) (output_key:buffer128)  =   
  (va_require_total va_b0 (va_code_KeyExpansionStdcall false) va_s0) /\ (va_get_ok va_s0)
    /\ (let key_ptr = ((va_get_reg rdi va_s0)) in let
    key_expansion_ptr = ((va_get_reg rsi va_s0)) in let key
    = (quad32_to_seq (buffer128_read input_key 0 (va_get_mem va_s0))) in (buffers_disjoint128
    input_key output_key) /\ (validSrcAddrs128 (va_get_mem va_s0) key_ptr input_key
    1) /\ (validDstAddrs128 (va_get_mem va_s0) key_expansion_ptr output_key 11))

let va_post (va_b0:va_code) (va_s0:va_state) (va_sM:va_state) (va_fM:va_fuel)
  (input_key:buffer128) (output_key:buffer128)  =  
  ((va_ensure_total va_b0 va_s0 va_sM va_fM) /\ (va_get_ok va_sM)
    /\ (let key_ptr = ((va_get_reg rdi va_s0)) in let
    key_expansion_ptr = ((va_get_reg rsi va_s0)) in let key
    = (quad32_to_seq (buffer128_read input_key 0 (va_get_mem va_s0))) in (buffers_disjoint128
    input_key output_key) /\ (validSrcAddrs128 (va_get_mem va_sM) key_ptr input_key
    1) /\ (validDstAddrs128 (va_get_mem va_sM) key_expansion_ptr output_key 11)) /\
    (let key_ptr = ((va_get_reg rdi va_s0)) in let
    key_expansion_ptr = ((va_get_reg rsi va_s0)) in let key
    = (quad32_to_seq (buffer128_read input_key 0 (va_get_mem va_s0))) in (modifies_buffer128
    output_key (va_get_mem va_s0) (va_get_mem va_sM)) /\ (forall j .
    {:pattern(buffer128_read output_key j (va_get_mem va_sM))}(0 <= j && j <= 10) ==>
    (buffer128_read output_key j (va_get_mem va_sM)) == (index (key_to_round_keys_LE
    AES_128 key) j))) /\ (va_state_eq va_sM (va_update_flags va_sM (va_update_xmm 3 va_sM
    (va_update_xmm 2 va_sM (va_update_xmm 1 va_sM (va_update_mem va_sM (va_update_reg rdx va_sM
    (va_update_ok va_sM va_s0)))))))))

val va_lemma_aes(va_b0:va_code) (va_s0:va_state)
  (input_key:buffer128) (output_key:buffer128) : Ghost ((va_sM:va_state) * (va_fM:va_fuel))
  (requires va_pre va_b0 va_s0 input_key output_key )
  (ensures (fun (va_sM, va_fM) -> va_post va_b0 va_s0 va_sM va_fM input_key output_key ))

let va_lemma_aes va_b0 va_s0 input_key output_key =
  va_lemma_KeyExpansionStdcall va_b0 va_s0 false input_key output_key

module X64.Vale.InsBasic

#verbatim{:interface}
open Types_s
open X64.Machine_s
open X64.Vale.State_i
open X64.Vale.Decls_i
open X64.Vale.QuickCode_i

unfold let trace_type = list observation
unfold let memTaint_type = map int taint
#endverbatim

#verbatim
open X64.Machine_s
open X64.Vale
open X64.Vale.State_i
open X64.Vale.StateLemmas_i
open X64.Vale.Decls_i
module S = X64.Bytes_Semantics_s
module TS = X64.Taint_Semantics_s
module P = X64.Print_s
open X64.Taint_Semantics_i
open FStar.List.Tot.Properties // Needed to facilitate understanding of the use of map in mk_taint_ins*

// Convenient packaging for lemma_valid_taint64
let lemma_valid_taint64_operand (o:va_operand) (s:va_state) : Lemma
  (requires valid_operand o s)
  (ensures TMem? o ==> Map.sel s.memTaint (X64.Memory_i.buffer_addr (TMem?.b o) s.mem + 8 `op_Multiply` (TMem?.index o)) == (TMem?.t o))
  =
  //admit();
  if TMem? o then (
    let open X64.Taint_Semantics_s in
    let tainted_mem:X64.Memory_i_s.memtaint = (state_to_S s).memTaint in
    let real_mem:X64.Memory_i_s.mem = s.mem in
    lemma_valid_taint64 (TMem?.b o)
                        tainted_mem
                        real_mem
                        (TMem?.index o)
                        (TMem?.t o);
    ()
  ) else ()

#endverbatim

#reset-options "--initial_fuel 4 --max_fuel 4 --max_ifuel 2 --z3rlimit 20"

var{:state ok()} ok:bool;
var{:state reg(Rax)} rax:nat64;
var{:state reg(Rbx)} rbx:nat64;
var{:state reg(Rcx)} rcx:nat64;
var{:state reg(Rdx)} rdx:nat64;
var{:state reg(Rsi)} rsi:nat64;
var{:state reg(Rdi)} rdi:nat64;
var{:state reg(Rbp)} rbp:nat64;
var{:state reg(Rsp)} rsp:nat64;
var{:state reg(R8)}  r8:nat64;
var{:state reg(R9)}  r9:nat64;
var{:state reg(R10)} r10:nat64;
var{:state reg(R11)} r11:nat64;
var{:state reg(R12)} r12:nat64;
var{:state reg(R13)} r13:nat64;
var{:state reg(R14)} r14:nat64;
var{:state reg(R15)} r15:nat64;
var{:state flags()} efl:nat64;
var{:state mem()} mem:mem;
var{:state memTaint()} memTaint:memTaint_type;

procedure{:quick exportOnly} AssertQuickType(ghost p:Type0) returns(ghost u:squash(p))
    requires
        p;
{
    u := tuple();
}

procedure{:instruction mk_taint_ins2(S.Mov64, dst, src, list(dst), list(src))}{:fast_instruction}{:quick exportOnly} Mov64(inout dst: dst_opr64, src: opr64)
    ensures
        dst == old(src);
{
    lemma_valid_taint64_operand(@src, old(this));
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.Add64(dst,src), list(dst), list(dst, src)), extract_taint(dst, src)))}{:quick exportOnly} Add64(inout dst: dst_opr64, src: opr64)
    modifies
        efl;
    requires
        src + dst < pow2_64;
    ensures
        dst == old(dst + src);
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.Add64(dst,src), list(dst), list(dst, src)), extract_taint(dst, src)))}{:fast_instruction}{:quick exportOnly} Add64Wrap(inout dst: dst_opr64, src: opr64)
    modifies
        efl;
    ensures
        dst == old(add_wrap(dst, src));
        cf(efl) == old(dst + src >= pow2_64);
{
}


procedure{:instruction Ins(TS.TaintedIns(tuple(S.Add64(dst,src), list(dst), list(dst, src)), extract_taint(dst, src)))}{:fast_instruction}{:quick exportOnly} Add64Wrap_Mem(inout dst: dst_opr64, src: opr64)
    modifies
        efl;
    ensures
        dst == old(add_wrap(dst, src));
        cf(efl) == old(dst + src >= pow2_64);
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.AddLea64(dst, src1, src2), list(dst), list(dst, src1, src2)), extract_taint(dst, src1, src2)))}{:quick exportOnly} AddLea64(out dst: dst_opr64, src1: opr64, src2: opr64)
    requires
        src1 + src2 < pow2_64;
    ensures
        dst == old(src1) + old(src2);
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.AddCarry64(dst, src), list(dst), list(dst, src)), extract_taint(dst, src)))}{:fast_instruction}{:quick exportOnly} Adc64Wrap(inout dst: dst_opr64, src: opr64)
    modifies
        efl;
    ensures
        dst == old(add_wrap(add_wrap(dst, src), (if cf(efl) then 1 else 0)));
        cf(efl) == old(dst + src + (if cf(efl) then 1 else 0)) >= pow2_64;
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.Adcx64(dst, src), list(dst), list(dst, src)), extract_taint(dst, src)))}{:fast_instruction}{:quick exportOnly} Adcx64Wrap(inout dst: dst_opr64, src: opr64)
    modifies
        efl;
    ensures
        dst == old(add_wrap(add_wrap(dst, src), (if cf(efl) then 1 else 0)));
        efl == update_cf(old(efl), old(dst + src + (if cf(efl) then 1 else 0)) >= pow2_64);
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.Adox64(dst, src), list(dst), list(dst, src)), extract_taint(dst, src)))}{:fast_instruction}{:quick exportOnly} Adox64Wrap(inout dst: dst_opr64, src: opr64)
    modifies
        efl;
    ensures
        dst == old(add_wrap(add_wrap(dst, src), (if overflow(efl) then 1 else 0)));
        efl == update_of(old(efl), old(dst + src + (if overflow(efl) then 1 else 0)) >= pow2_64);
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.Sub64(dst, src), list(dst), list(dst, src)), extract_taint(dst, src)))}{:fast_instruction}{:quick exportOnly} Sub64(inout dst: dst_opr64, src: opr64)
    requires
        0 <= dst - src;
    modifies 
        efl;
    ensures
        dst == old(dst) - old(src);
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.Sub64(dst, src), list(dst), list(dst, src)), extract_taint(dst, src)))}{:quick exportOnly} Sub64Wrap(inout dst: dst_opr64, src: opr64)
    modifies
        efl;
    ensures
        dst == old(dst - src) % pow2_64;
{
}

#verbatim
let lemma_fundamental_div_mod (a b:nat64) :
  Lemma (pow2_64 `op_Multiply` (FStar.UInt.mul_div #64 a b) + (FStar.UInt.mul_mod #64 a b) == a `op_Multiply` b)
  =
  ()
#endverbatim

procedure{:instruction Ins(TS.TaintedIns(tuple(S.Mul64(src), list(OReg(Rax), OReg(Rdx)), list(OReg(Rax), src)), get_taint(src)))}{:fast_instruction}{:quick exportOnly} Mul64Wrap(src: opr64)
    modifies
        efl;
        rax;
        rdx;
    ensures
        pow2_64 * rdx + rax == old(rax * src);
{
    lemma_fundamental_div_mod(old(rax), old(src));
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.Mulx64(dst_hi, dst_lo, src), list(dst_hi, dst_lo), list(OReg(Rdx), src)), extract_taint3(dst_hi, dst_lo, src)))}{:fast_instruction}{:quick exportOnly} Mulx64(out dst_hi: dst_opr64, out dst_lo: dst_opr64, src: opr64)
    requires @dst_hi != @dst_lo;
    reads
        rdx;
    ensures
        pow2_64 * dst_hi + dst_lo == old(rdx * src);
{
    lemma_fundamental_div_mod(old(rdx), old(src));
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.IMul64(dst, src), list(dst), list(dst, src)), extract_taint(dst, src)))}{:fast_instruction}{:quick exportOnly} IMul64(inout dst: dst_opr64, src: opr64)
    requires
        dst * src < pow2_64;
    modifies
        efl;
    ensures
        dst == old(dst * src);
{
    lemma_mul_nat(old(dst), old(src));
    lemma_mul_in_bounds(old(dst), old(src));
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.Xor64(dst, src), list(dst), list(dst, src)), extract_taint(dst, src)))}{:quick exportOnly} Xor64(inout dst: dst_opr64, src: opr64)
    modifies 
        efl;
    ensures
        dst == old(ixor(dst,src));
        !overflow(efl);
        !cf(efl);
        
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.And64(dst, src), list(dst), list(dst, src)), extract_taint(dst, src)))}{:fast_instruction}{:quick exportOnly} And64(inout dst: dst_opr64, src: opr64)
    modifies 
        efl;
    ensures
        dst == old(iand(dst,src));
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.Shl64(dst, amt), list(dst), list(dst, amt)), extract_taint(dst, amt)))}{:quick exportOnly} Shl64(inout dst: dst_opr64, amt: shift_amt64)
    modifies
        efl;
//    requires
//        0 <= src < 64;
    ensures
        dst == old(ishl(dst, amt));
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.Shr64(dst, amt), list(dst), list(dst, amt)), extract_taint(dst, amt)))}{:fast_instruction}{:quick exportOnly} Shr64(inout dst: dst_opr64, amt: shift_amt64)
    modifies
        efl;
    ensures
        dst == old(ishr(dst, amt));
{
}

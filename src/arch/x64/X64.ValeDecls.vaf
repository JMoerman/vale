#verbatim interface
module X64.ValeDecls

open X64.Machine_s
open FStar.UInt
open FStar.Map

(* Type aliases *)
type va_bool = bool
type va_int = int
val ins : Type0
val ocmp : Type0
type va_code = precode ins ocmp
let va_codes = list va_code

type va_state = state
type va_operand = operand
type va_reg_operand = o:operand{OReg? o}
type va_dst_operand = dst_op
type va_shift_amt = operand
type va_cmp = operand
type va_register = reg

val cf : (flags:nat64) -> bool

let va_subscript (m:mem) (ptr:int) :nat64 = FStar.UInt64.v m.[ptr]

(* Constructors *)
let va_op_operand_reg (r:reg) :va_operand = OReg r
let va_const_operand (n:nat{normalize (n < pow2 64)}) = OConst (FStar.UInt64.uint_to_t n)
let va_const_shift_amt (n:nat{normalize (n < 64)}) :va_shift_amt = OConst (FStar.UInt64.uint_to_t n)
let va_op_cmp_reg (r:reg) :va_cmp = OReg r
let va_const_cmp (n:nat{normalize (n < pow2 64)}) :va_cmp = OConst (FStar.UInt64.uint_to_t n)
let va_coerce_register_to_operand (r:va_register) :va_operand = OReg r
let va_op_register (r:reg) :va_register = r
let va_op_dst_operand_reg (r:reg{ not (Rsp? r) }) : va_dst_operand = OReg r
let va_coerce_operand_to_dst_operand (o:va_operand{ valid_dst o }) : va_dst_operand = o
let va_coerce_dst_operand_to_operand (o:va_dst_operand) : va_operand = o

(* Predicates *)
let va_is_src_operand_uint64 (o:operand) (s:va_state) = valid_operand o s
let va_is_dst_operand_uint64 (o:operand) (s:va_state) = valid_dst o
let va_is_dst_dst_operand_uint64 (o:va_dst_operand) (s:va_state) = valid_operand o s
let va_is_src_register_int (r:reg) (s:va_state) :bool = true
let va_is_dst_register (r:reg) (s:va_state) :bool = true
let va_is_src_shift_amt_uint64 (o:operand) (s:va_state) = true
let va_is_src_reg_operand_uint64 (o:operand) (s:va_state) = OReg? o

let valid_src_addr (m:mem) (addr:int) : bool = m `contains` addr
let valid_dst_addr (m:mem) (addr:int) : bool = m `contains` addr

(* Getters *)
let va_get_ok (s:va_state) :bool = s.ok
let va_get_flags (s:va_state) :nat64 = FStar.UInt64.v s.flags
let va_get_reg (r:reg) (s:va_state) :nat64 = FStar.UInt64.v (eval_reg r s)
let va_get_mem (s:va_state) :mem = s.mem

let get_reg (o:va_reg_operand) :reg = OReg?.r o

(* Framing: va_update_foo means the two states are the same except for foo *)
let va_update_ok (sM:va_state) (sK:va_state) :va_state  = { sK with ok = sM.ok }
let va_update_flags  (sM:va_state) (sK:va_state) :va_state  = { sK with flags = sM.flags }
let va_update_reg (r:reg) (sM:va_state) (sK:va_state) :va_state = { sK with regs = sK.regs.[r] <- eval_reg r sM }
let va_update (sK:va_state) (idx:int) (v:nat64) :mem = sK.mem.[idx]<- v 
							
let va_update_mem (sM:va_state) (sK:va_state) :va_state = { sK with mem = sM.mem }
let va_update_operand (o:operand) (sM:va_state) (sK:va_state) :va_state =
  match o with
  | OConst n -> sK
  | OReg r -> va_update_reg r sM sK
  | OMem m -> va_update_mem sM sK 
let va_update_dst_operand (o:dst_op) (sM:va_state) (sK:va_state) :va_state =
  va_update_operand o sM sK   
let va_update_register (r:reg) (sM:va_state) (sK:va_state) :va_state = va_update_reg r sM sK

(* Evaluation *)
let va_eval_operand_uint64     (s:va_state) (o:va_operand)     :nat64 = FStar.UInt64.v (eval_operand o s)
let va_eval_dst_operand_uint64 (s:va_state) (o:va_dst_operand) :nat64 = FStar.UInt64.v (eval_operand o s)
let va_eval_shift_amt_uint64   (s:va_state) (o:va_shift_amt)   :nat64 = FStar.UInt64.v (eval_operand o s)
let va_eval_cmp_uint64         (s:va_state) (r:va_cmp)         :nat64 = FStar.UInt64.v (eval_operand r s)
let va_eval_register_uint64    (s:va_state) (r:va_register)    :nat64 = FStar.UInt64.v (eval_reg r s)
let va_eval_reg_operand_uint64 (s:va_state) (o:va_reg_operand) :nat64 = FStar.UInt64.v (eval_reg (OReg?.r o) s)

(** Constructors for va_codes *)
let va_CNil () :va_codes = []
let va_CCons (hd:va_code) (tl:va_codes) :va_codes = hd::tl

(** Constructors for va_code *)
let va_Block (block:va_codes) :va_code = Block block
let va_IfElse (ifCond:ocmp) (ifTrue:va_code) (ifFalse:va_code) :va_code = IfElse ifCond ifTrue ifFalse
let va_While (whileCond:ocmp) (whileBody:va_code) (inv:operand) :va_code = While whileCond whileBody inv
val va_cmp_eq (o1:va_operand) (o2:va_operand) : ocmp
val va_cmp_ne (o1:va_operand) (o2:va_operand) : ocmp
val va_cmp_le (o1:va_operand) (o2:va_operand) : ocmp
val va_cmp_ge (o1:va_operand) (o2:va_operand) : ocmp
val va_cmp_lt (o1:va_operand) (o2:va_operand) : ocmp
val va_cmp_gt (o1:va_operand) (o2:va_operand) : ocmp
let va_get_block (c:va_code{Block? c}) :va_codes = Block?.block c
let va_get_ifCond (c:va_code{IfElse? c}) :ocmp = IfElse?.ifCond c
let va_get_ifTrue (c:va_code{IfElse? c}) :va_code = IfElse?.ifTrue c
let va_get_ifFalse (c:va_code{IfElse? c}) :va_code = IfElse?.ifFalse c
let va_get_whileCond (c:va_code{While? c}) :ocmp = While?.whileCond c
let va_get_whileBody (c:va_code{While? c}) :va_code = While?.whileBody c

(* ok for now but no need to actually expose the definition.
   instead expose lemmas about it *)
let va_state_eq (s_0:va_state) (s_1:va_state) :Type0 = 
  s_0.ok == s_1.ok /\
  Map.equal s_0.regs s_1.regs /\
  s_0.flags == s_1.flags /\
  Map.equal s_0.mem s_1.mem

(*not sure about the decreases part*)
val va_eval_code : (c:va_code) -> (s:va_state) -> Tot (option va_state)

unfold let va_require (block:va_codes) (c:va_code) (s_0:va_state) (s_1:va_state) :Type0 =
  Cons? block                         /\
  Cons?.hd block == c                 /\
  Some s_1 == va_eval_code (va_Block block) s_0    /\
  (forall (r:reg). s_0.regs `contains` r)  //what is this?

unfold let va_ensure (b_0:va_codes) (b_1:va_codes) (s_0:va_state) (s_1:va_state) (sN:va_state) :Type0 =
  Cons? b_0                         /\
  Cons?.tl b_0 == b_1                /\
  Some(s_1) == va_eval_code (Cons?.hd b_0) s_0     /\
  Some(sN)  == va_eval_code (va_Block b_1) s_1     /\
  (forall (r:reg). s_1.regs `contains` r)

val eval_ocmp : s:va_state -> c:ocmp -> GTot bool

val lemma_cmp_eq : s:va_state -> o1:va_operand -> o2:va_operand -> Lemma
  (requires True)
  (ensures  (eval_ocmp s (va_cmp_eq o1 o2)) <==> (va_eval_operand_uint64 s o1 == va_eval_operand_uint64 s o2))
  [SMTPat (eval_ocmp s (va_cmp_eq o1 o2))]

val lemma_cmp_ne : s:va_state -> o1:va_operand -> o2:va_operand -> Lemma
  (requires True)
  (ensures  (eval_ocmp s (va_cmp_ne o1 o2)) <==> (va_eval_operand_uint64 s o1 <> va_eval_operand_uint64 s o2))
  [SMTPat (eval_ocmp s (va_cmp_ne o1 o2))]

val lemma_cmp_le : s:va_state -> o1:va_operand -> o2:va_operand -> Lemma
  (requires True)
  (ensures  (eval_ocmp s (va_cmp_le o1 o2)) <==> (va_eval_operand_uint64 s o1 <= va_eval_operand_uint64 s o2))
  [SMTPat (eval_ocmp s (va_cmp_le o1 o2))]

val lemma_cmp_ge : s:va_state -> o1:va_operand -> o2:va_operand -> Lemma
  (requires True)
  (ensures  (eval_ocmp s (va_cmp_ge o1 o2)) <==> (va_eval_operand_uint64 s o1 >= va_eval_operand_uint64 s o2))
  [SMTPat (eval_ocmp s (va_cmp_ge o1 o2))]

val lemma_cmp_lt : s:va_state -> o1:va_operand -> o2:va_operand -> Lemma
  (requires True)
  (ensures  (eval_ocmp s (va_cmp_lt o1 o2)) <==> (va_eval_operand_uint64 s o1 < va_eval_operand_uint64 s o2))
  [SMTPat (eval_ocmp s (va_cmp_lt o1 o2))]

val lemma_cmp_gt : s:va_state -> o1:va_operand -> o2:va_operand -> Lemma
  (requires True)
  (ensures  (eval_ocmp s (va_cmp_gt o1 o2)) <==> (va_eval_operand_uint64 s o1 > va_eval_operand_uint64 s o2))
  [SMTPat (eval_ocmp s (va_cmp_gt o1 o2))]

val va_lemma_block : (b_0:va_codes) -> (s_0:va_state) -> (sN:va_state) ->
  Ghost (va_state * va_code * va_codes)
  (requires (Cons? b_0 /\ Some sN == va_eval_code (va_Block b_0) s_0))
  (ensures  (fun (s_1, c_1, b_1) ->
    b_0 == va_CCons c_1 b_1 /\
    Some s_1 == va_eval_code c_1 s_0 /\
    Some sN == va_eval_code (va_Block b_1) s_1))

val va_lemma_empty : (s_0:va_state) -> (sN:va_state) -> Ghost va_state
  (requires (Some sN == va_eval_code (va_Block (va_CNil ())) s_0))
  (ensures  (fun sM -> sM == s_0 /\ sM == sN))

val va_lemma_ifElse : ifb:ocmp -> ct:va_code -> cf:va_code -> s_0:va_state -> sN:va_state -> Ghost (bool * va_state)
  (requires (Some sN == va_eval_code (IfElse ifb ct cf) s_0))
  (ensures  (fun (cond, sM) ->
    cond == eval_ocmp s_0 ifb /\
    sM == s_0 /\
    Some sN == (if cond then va_eval_code ct sM else va_eval_code cf sM)))

(* maybe we want these to be transparent*)
val logxor64 : (x:nat64) -> (y:nat64) -> nat64
val logand64 : (x:nat64) -> (y:nat64) -> nat64
val shift_left64 : (x:nat64) -> (amt:nat64) -> nat64
val shift_right64 : (x:nat64) -> (amt:nat64) -> nat64

let add_wrap (x:int) (y:int) = if x + y < nat64_max then x + y else x + y - nat64_max
let eq_int (i1:int) (i2:int) = i1 == i2

val printer : Type0
val print_string : string -> FStar.All.ML unit
val print_header : printer -> FStar.All.ML unit
val print_proc : (name:string) -> (code:va_code) -> (label:int) -> (p:printer) -> FStar.All.ML unit
val print_footer : printer -> FStar.All.ML unit
val masm : printer
val gcc : printer
#endverbatim

#verbatim
module X64.ValeDecls
open X64.Machine_s
open X64.Semantics_s
open FStar.UInt
open FStar.Map
#reset-options "--initial_fuel 2 --max_fuel 2"

let ins = X64.Semantics_s.ins
type ocmp = X64.Semantics_s.ocmp
let cf n = X64.Semantics_s.cf (X64.Semantics_s.u n)

let va_cmp_eq o1 o2 = OEq o1 o2
let va_cmp_ne o1 o2 = ONe o1 o2
let va_cmp_le o1 o2 = OLe o1 o2
let va_cmp_ge o1 o2 = OGe o1 o2
let va_cmp_lt o1 o2 = OLt o1 o2
let va_cmp_gt o1 o2 = OGt o1 o2

(*not sure about the decreases part*)
let va_eval_code c s = eval_code c s

let eval_ocmp s c = X64.Semantics_s.eval_ocmp s c

let lemma_cmp_eq s o1 o2 = ()
let lemma_cmp_ne s o1 o2 = ()
let lemma_cmp_le s o1 o2 = ()
let lemma_cmp_ge s o1 o2 = ()
let lemma_cmp_lt s o1 o2 = ()
let lemma_cmp_gt s o1 o2 = ()

let va_lemma_block (b_0:va_codes) (s_0:va_state) (sN:va_state) =
  let c_1::b_1 = b_0 in
  Some?.v (va_eval_code c_1 s_0), c_1, b_1

let va_lemma_empty (s_0:va_state) (sN:va_state) = s_0

let va_lemma_ifElse (ifb:ocmp) (ct:code) (cf:code) (s_0:va_state) (sN:va_state) =
  eval_ocmp s_0 ifb, s_0

let logxor64 (x:nat64) (y:nat64) :nat64 =
  X64.Semantics_s.logxor x y

let logand64 (x:nat64) (y:nat64) :nat64 =
  X64.Semantics_s.logand x y

let shift_left64 (x:nat64) (amt:nat64) :nat64 =
  X64.Semantics_s.shift_left x amt

let shift_right64 (x:nat64) (amt:nat64) :nat64 =
  X64.Semantics_s.shift_right x amt

let printer = X64.Print_s.printer
let print_string = FStar.IO.print_string
let print_header = X64.Print_s.print_header
let print_proc = X64.Print_s.print_proc
let print_footer = X64.Print_s.print_footer
let masm = X64.Print_s.masm
let gcc = X64.Print_s.gcc

#endverbatim

var{:state ok()} ok:bool;
var{:state reg(Rax)} rax:int;
var{:state reg(Rbx)} rbx:int;
var{:state reg(Rcx)} rcx:int;
var{:state reg(Rdx)} rdx:int;
var{:state reg(Rsi)} rsi:int;
var{:state reg(Rdi)} rdi:int;
var{:state reg(Rbp)} rbp:int;
var{:state reg(Rsp)} rsp:int;
var{:state reg(R8)}  r8:int;
var{:state reg(R9)}  r9:int;
var{:state reg(R10)} r10:int;
var{:state reg(R11)} r11:int;
var{:state reg(R12)} r12:int;
var{:state reg(R13)} r13:int;
var{:state reg(R14)} r14:int;
var{:state reg(R15)} r15:int;
var{:state flags()} efl:int;
var{:state mem()} mem:int;

procedure{:instruction Ins(Mov64(dst,src))} Mov64(inout dst_operand dst:uint64, operand src:uint64)
    ensures
        dst == old(src);
{
}

procedure{:instruction Ins(Mov64(dst, OMem(MReg(get_reg(src), offset))))} Load64(
    out dst_operand dst:uint64,
        reg_operand src:uint64,
        inline offset:int)
    reads
        mem;
    requires
        valid_src_addr(mem, src + offset);
    ensures
        dst == mem[old(src) + offset];
{
}

// Testing store
procedure{:instruction Ins(Mov64(OMem(MReg(get_reg(dst), offset)), src))} Store64(
        operand src:uint64,
        reg_operand dst:uint64,
        inline offset:int)
    modifies
        mem;
    requires
        valid_dst_addr(mem, dst + offset);
    ensures
        mem == old(mem)[old(dst + offset) := src];
{
}


procedure{:instruction Ins(Add64(dst,src))} Add64(inout dst_operand dst:uint64, operand src:uint64)
    modifies
        efl;
    requires
        src + dst < nat64_max;
    ensures
        eq_int(dst, old(dst + src));
{
}

procedure{:instruction Ins(Add64(dst,src))} Add64Wrap(inout dst_operand dst:uint64, operand src:uint64)
    modifies
        efl;
    ensures
        dst == old(add_wrap(dst, src));
        cf(efl) == old(dst + src >= nat64_max);
{
}

procedure{:instruction Ins(AddLea64(dst, src1, src2))} AddLea64(out dst_operand dst:uint64, operand src1:uint64, operand src2:uint64)
    requires
        src1 + src2 < nat64_max;
    ensures
        eq_int(dst, old(src1) + old(src2));
{
}

procedure{:instruction Ins(AddCarry64(dst, src))} Adc64Wrap(inout dst_operand dst:uint64, operand src:uint64)
    modifies
        efl;
    ensures
        dst == old(add_wrap(add_wrap(dst, src), (if cf(efl) then 1 else 0)));
        cf(efl) == old(dst + src + (if cf(efl) then 1 else 0)) >= nat64_max;
{
}

procedure{:instruction Ins(Sub64(dst, src))} Sub64(inout dst_operand dst:uint64, operand src:uint64)
    requires
        0 <= dst - src;
    modifies 
        efl;
    ensures
        eq_int(dst, old(dst) - old(src));
{
}

procedure{:instruction Ins(Sub64(dst, src))} Sub64Wrap(inout dst_operand dst:uint64, operand src:uint64)
    modifies
        efl;
    ensures
        dst == old(dst - src) % nat64_max;
{
}

procedure{:instruction Ins(Mul64(src))} Mul64Wrap(operand src:uint64)
    modifies
        efl;
        rax;
        rdx;
    ensures
        nat64_max * rdx + rax == old(rax * src);
{
}

#verbatim
#reset-options "--z3cliopt smt.arith.nl=true --initial_fuel 2 --max_fuel 2"
#endverbatim
procedure{:instruction Ins(IMul64(dst, src))} IMul64(inout dst_operand dst:uint64, operand src:uint64)
    requires
        dst * src < nat64_max;
    modifies
        efl;
    ensures
        eq_int(dst, (old(dst * src)));
{
}
#verbatim
#reset-options "--initial_fuel 2 --max_fuel 2"
#endverbatim

procedure{:instruction Ins(Xor64(dst, src))} Xor64(inout dst_operand dst:uint64, operand src:uint64)
    modifies 
        efl;
    ensures
        dst == old(logxor64(dst,src));
{
}

procedure{:instruction Ins(And64(dst, src))} And64(inout dst_operand dst:uint64, operand src:uint64)
    modifies 
        efl;
    ensures
        dst == old(logand64(dst,src));
{
}

procedure{:instruction Ins(Shl64(dst, amt))} Shl64(inout dst_operand dst:uint64, shift_amt amt:uint64)
    modifies
        efl;
//    requires
//        0 <= src < 64;
    ensures
        dst == old(shift_left64(dst, amt));
{
}

procedure{:instruction Ins(Shr64(dst, amt))} Shr64(inout dst_operand dst:uint64, shift_amt amt:uint64)
    modifies
        efl;
    ensures
        dst == old(shift_right64(dst, amt));
{
}


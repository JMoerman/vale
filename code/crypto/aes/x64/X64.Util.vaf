include "../../../arch/x64/X64.Vale.InsBasic.vaf"
include "../../../arch/x64/X64.Vale.InsMem.vaf"
include "../../../arch/x64/X64.Vale.InsVector.vaf"

module X64.Util

#verbatim{:interface}{:implementation}
open Opaque_s
open FStar.Seq
open Words_s
open Words.Seq_s
open Types_s
open Arch.Types
open AES_s
open GCTR_s
open GCTR
open GCM
open GHash_s
open GHash
open GCM_s
open X64.AES
open GF128_s
open GF128
open X64.Poly1305.Math
open GCM_helpers
open X64.GHash
open X64.GCTR
open X64.Machine_s
open X64.Memory
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.InsBasic
open X64.Vale.InsMem
open X64.Vale.InsVector
open X64.Vale.InsAes
open X64.Vale.QuickCode
open X64.Vale.QuickCodes
open X64.GF128_Mul
#endverbatim

#reset-options "--z3rlimit 30"

procedure {:quick} zero_quad32_buffer(ghost b:buffer128)
    requires/ensures
        buffer_readable(mem, b);
        valid_taint_buf128(b, mem, memTaint, Secret);
        buffer_length(b) == 1;
        rdi == buffer_addr(b, mem);
    ensures
        rbx == old(rbx);
        rbp == old(rbp);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);
        r15 == old(r15);

        modifies_buffer128(b, old(mem), mem);
        buffer128_read(b, 0, mem) == Mkfour(0, 0, 0, 0);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
        ZeroXmm(xmm1);
        Store128_buffer(rdi, xmm1, 0, Secret, b, 0);
}

procedure {:quick} zero_quad32_buffer_win(ghost stack_b:buffer64, ghost b:buffer128)
    requires/ensures
        buffer_readable(mem, b);
        valid_taint_buf128(b, mem, memTaint, Secret);
        buffer_length(b) == 1;
    requires
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(b)));
        buffer_readable(mem, stack_b);
        buffer_length(stack_b) >= 2;
        valid_stack_slots(mem, rsp, stack_b, 0, memTaint);
        rcx == buffer_addr(b, mem);
    ensures
        rbx == old(rbx);
        rbp == old(rbp);
        rdi == old(rdi);
        rsi == old(rsi);
        rsp == old(rsp);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);
        r15 == old(r15);
        xmm6 == old(xmm6);
        xmm7 == old(xmm7);
        xmm8 == old(xmm8);
        xmm9 == old(xmm9);
        xmm10 == old(xmm10);
        xmm11 == old(xmm11);
        xmm12 == old(xmm12);
        xmm13 == old(xmm13);
        xmm14 == old(xmm14);
        xmm15 == old(xmm15);

        modifies_buffer128(b, old(mem), mem);
        buffer128_read(b, 0, mem) == Mkfour(0, 0, 0, 0);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
        ZeroXmm(xmm1);
        Store128_buffer(rcx, xmm1, 0, Secret, b, 0);
}

procedure {:quick} mk_quad32_lo0_be_1_buffer(ghost b:buffer128)
    requires/ensures
    requires
        buffer_readable(mem, b);
        valid_taint_buf128(b, mem, memTaint, Secret);
        buffer_length(b) == 1;
        rdi == buffer_addr(b, mem);
    ensures
        rbx == old(rbx);
        rbp == old(rbp);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);
        r15 == old(r15);

        modifies_buffer128(b, old(mem), mem);
        let old_b := buffer128_read(b, 0, old(mem));
        let new_b := buffer128_read(b, 0, mem);
        new_b == Mkfour (1, old_b.lo1, old_b.hi2, old_b.hi3);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
     Load128_buffer(xmm1, rdi, 0, Secret, b, 0);
     PinsrdImm(xmm1, 1, 0, rax);
     Store128_buffer(rdi, xmm1, 0, Secret, b, 0);

}

procedure {:quick} mk_quad32_lo0_be_1_buffer_win(ghost stack_b:buffer64, ghost b:buffer128)
    requires
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(b)));
        buffer_readable(mem, stack_b);
        buffer_readable(mem, b);
        buffer_length(b) == 1;
        buffer_length(stack_b) >= 2;
        valid_stack_slots(mem, rsp, stack_b, 0, memTaint);
        rcx == buffer_addr(b, mem);
        valid_taint_buf128(b, mem, memTaint, Secret);
    ensures
        rbx == old(rbx);
        rbp == old(rbp);
        rdi == old(rdi);
        rsi == old(rsi);
        rsp == old(rsp);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);
        r15 == old(r15);
        xmm6 == old(xmm6);
        xmm7 == old(xmm7);
        xmm8 == old(xmm8);
        xmm9 == old(xmm9);
        xmm10 == old(xmm10);
        xmm11 == old(xmm11);
        xmm12 == old(xmm12);
        xmm13 == old(xmm13);
        xmm14 == old(xmm14);
        xmm15 == old(xmm15);

        modifies_buffer128(b, old(mem), mem);
        let old_b := buffer128_read(b, 0, old(mem));
        let new_b := buffer128_read(b, 0, mem);
        new_b == Mkfour (1, old_b.lo1, old_b.hi2, old_b.hi3);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
     Load128_buffer(xmm1, rcx, 0, Secret, b, 0);
     PinsrdImm(xmm1, 1, 0, rax);
     Store128_buffer(rcx, xmm1, 0, Secret, b, 0);
}



procedure {:quick} quad32_xor_buffer(
  ghost src1:buffer128,
  ghost src2:buffer128,
  ghost dst:buffer128)
    requires
        buffers_disjoint128(src1, src2) \/ src1 == src2;
        buffers_disjoint128(src1, dst) \/ src1 == dst;
        buffers_disjoint128(src2, dst) \/ src2 == dst;
        buffer_readable(mem, src1);
        buffer_readable(mem, src2);
        buffer_readable(mem, dst);
        valid_taint_buf128(src1, mem, memTaint, Secret);
        valid_taint_buf128(src2, mem, memTaint, Secret);
        valid_taint_buf128(dst, mem, memTaint, Secret);
        rdi == buffer_addr(src1, mem);
        rsi == buffer_addr(src2, mem);
        rdx == buffer_addr(dst, mem);
        buffer_length(src1) == 1;
        buffer_length(src2) == 1;
        buffer_length(dst) == 1;
   ensures
        rbx == old(rbx);
        rbp == old(rbp);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);
        r15 == old(r15);

        modifies_buffer128(dst, old(mem), mem);
        buffer128_read(dst, 0, mem) == quad32_xor(buffer128_read(src1, 0, old(mem)), buffer128_read(src2, 0, old(mem)));
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
        Load128_buffer(xmm1, rdi, 0, Secret, src1, 0);
        Load128_buffer(xmm2, rsi, 0, Secret, src2, 0);
        Pxor(xmm1, xmm2);
        Store128_buffer(rdx, xmm1, 0, Secret, dst, 0);
}

procedure {:quick} quad32_xor_buffer_win(ghost stack_b:buffer64, ghost src1:buffer128, ghost src2:buffer128, ghost dst:buffer128)
    requires
        buffers_disjoint128(src1, src2) \/ src1 == src2;
        buffers_disjoint128(src1, dst) \/ src1 == dst;
        buffers_disjoint128(src2, dst) \/ src2 == dst;
        locs_disjoint(list(loc_buffer(src1), loc_buffer(stack_b)));
        locs_disjoint(list(loc_buffer(src2), loc_buffer(stack_b)));
        locs_disjoint(list(loc_buffer(dst), loc_buffer(stack_b)));
        buffer_readable(mem, stack_b);
        buffer_readable(mem, src1);
        buffer_readable(mem, src2);
        buffer_readable(mem, dst);
        buffer_length(stack_b) >= 4;
        valid_stack_slots(mem, rsp, stack_b, 0, memTaint);
        rcx == buffer_addr(src1, mem);
        rdx == buffer_addr(src2, mem);
        r8 == buffer_addr(dst, mem);

        buffer_length(src1) == 1;
        buffer_length(src2) == 1;
        buffer_length(dst) == 1;

        valid_taint_buf128(src1, mem, memTaint, Secret);
        valid_taint_buf128(src2, mem, memTaint, Secret);
        valid_taint_buf128(dst, mem, memTaint, Secret);
    ensures
        rbx == old(rbx);
        rbp == old(rbp);
        rdi == old(rdi);
        rsi == old(rsi);
        rsp == old(rsp);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);
        r15 == old(r15);
        xmm6 == old(xmm6);
        xmm7 == old(xmm7);
        xmm8 == old(xmm8);
        xmm9 == old(xmm9);
        xmm10 == old(xmm10);
        xmm11 == old(xmm11);
        xmm12 == old(xmm12);
        xmm13 == old(xmm13);
        xmm14 == old(xmm14);
        xmm15 == old(xmm15);

        modifies_buffer128(dst, old(mem), mem);
        buffer128_read(dst, 0, mem) == quad32_xor(buffer128_read(src1, 0, old(mem)), buffer128_read(src2, 0, old(mem)));
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
        Load128_buffer(xmm1, rcx, 0, Secret, src1, 0);
        Load128_buffer(xmm2, rdx, 0, Secret, src2, 0);
        Pxor(xmm1, xmm2);
        Store128_buffer(r8, xmm1, 0, Secret, dst, 0);
}

procedure {:quick} gcm_load_xor_store_buffer(
  ghost plain_b:buffer128,
  ghost mask_b:buffer128,
  ghost cipher_b:buffer128,
  ghost offset:nat64,
  ghost num_blocks:nat64,
  ghost key:aes_key_LE(AES_128),
  ghost iv:quad32)
    requires/ensures
        buffer_readable(mem, plain_b);
        buffer_readable(mem, mask_b);
        buffer_readable(mem, cipher_b);

        valid_taint_buf128(plain_b, mem, memTaint, Secret);
        valid_taint_buf128(mask_b, mem, memTaint, Secret);
        valid_taint_buf128(cipher_b, mem, memTaint, Secret);
    requires
        locs_disjoint(list(loc_buffer(plain_b), loc_buffer(mask_b), loc_buffer(cipher_b)));
        rdi == buffer_addr(plain_b, mem);
        rsi == buffer_addr(mask_b, mem);
        rdx == buffer_addr(cipher_b, mem);
        rcx == offset;

        buffer_length(plain_b) >= num_blocks;
        buffer_length(cipher_b) == buffer_length(plain_b);
        buffer_length(mask_b) == 1;

        let mask := buffer128_read(mask_b, 0, mem);
        let plain := buffer128_as_seq(mem, plain_b);
        let cipher := buffer128_as_seq(mem, cipher_b);
        offset < num_blocks;
        buffer_addr(plain_b, mem) + offset * 16 < pow2_64;
        buffer_addr(cipher_b, mem) + offset * 16 < pow2_64;
        mask == aes_encrypt_BE(AES_128, key, inc32(iv, offset));
        gctr_partial(AES_128, offset, plain, cipher, key, iv);

    ensures
        rbx == old(rbx);
        rbp == old(rbp);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);
        r15 == old(r15);

        modifies_buffer128(cipher_b, old(mem), mem);
        let mask := buffer128_read(mask_b, 0, old(mem));
        let plain := buffer128_as_seq(mem, plain_b);
        let old_cipher := buffer128_as_seq(old(mem), cipher_b);
        let cipher := buffer128_as_seq(mem, cipher_b);
        gctr_partial(AES_128, offset + 1, plain, cipher, key, iv);
        slice(cipher, 0, offset) == slice(old_cipher, 0, offset);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{

        IMul64(rcx, 16);
        Add64(rdi, rcx);
        Load128_buffer(xmm2, rdi, 0, Secret, plain_b, offset);
        Load128_buffer(xmm0, rsi, 0, Secret, mask_b, 0);
        Pxor(xmm2, xmm0);
        Add64(rdx, rcx);
        Store128_buffer(rdx, xmm2, 0, Secret, cipher_b, offset);

}


procedure {:quick} gcm_load_xor_store_buffer_win(
  ghost stack_b:buffer64,
  ghost plain_b:buffer128,
  ghost mask_b:buffer128,
  ghost cipher_b:buffer128,
  ghost offset:nat64,
  ghost num_blocks:nat64,
  ghost key:aes_key_LE(AES_128),
  ghost iv:quad32)
    requires/ensures
        buffer_readable(mem, plain_b);
        buffer_readable(mem, mask_b);
        buffer_readable(mem, cipher_b);

        valid_taint_buf128(plain_b, mem, memTaint, Secret);
        valid_taint_buf128(mask_b, mem, memTaint, Secret);
        valid_taint_buf128(cipher_b, mem, memTaint, Secret);
    requires
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(plain_b), loc_buffer(mask_b), loc_buffer(cipher_b)));
        buffer_readable(mem, stack_b);

        buffer_length(stack_b) >= 5;
        valid_stack_slots(mem, rsp, stack_b, 0, memTaint);
        rcx == buffer_addr(plain_b, mem);
        rdx == buffer_addr(mask_b, mem);
        r8 == buffer_addr(cipher_b, mem);
        r9 == offset;

        buffer_length(plain_b) >= num_blocks;
        buffer_length(cipher_b) == buffer_length(plain_b);
        buffer_length(mask_b) == 1;

        let mask := buffer128_read(mask_b, 0, mem);
        let plain := buffer128_as_seq(mem, plain_b);
        let cipher := buffer128_as_seq(mem, cipher_b);
        offset < num_blocks;
        buffer_addr(plain_b, mem) + offset * 16 < pow2_64;
        buffer_addr(cipher_b, mem) + offset * 16 < pow2_64;
        mask == aes_encrypt_BE(AES_128, key, inc32(iv, offset));
        gctr_partial(AES_128, offset, plain, cipher, key, iv);

    ensures
        rbx == old(rbx);
        rbp == old(rbp);
        rdi == old(rdi);
        rsi == old(rsi);
        rsp == old(rsp);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);
        r15 == old(r15);
        xmm6 == old(xmm6);
        xmm7 == old(xmm7);
        xmm8 == old(xmm8);
        xmm9 == old(xmm9);
        xmm10 == old(xmm10);
        xmm11 == old(xmm11);
        xmm12 == old(xmm12);
        xmm13 == old(xmm13);
        xmm14 == old(xmm14);
        xmm15 == old(xmm15);

        modifies_buffer128(cipher_b, old(mem), mem);
        let mask := buffer128_read(mask_b, 0, old(mem));
        let plain := buffer128_as_seq(mem, plain_b);
        let old_cipher := buffer128_as_seq(old(mem), cipher_b);
        let cipher := buffer128_as_seq(mem, cipher_b);
        gctr_partial(AES_128, offset + 1, plain, cipher, key, iv);
        slice(cipher, 0, offset) == slice(old_cipher, 0, offset);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
        IMul64(r9, 16);
        Add64(rcx, r9);
        Load128_buffer(xmm2, rcx, 0, Secret, plain_b, offset);
        Load128_buffer(xmm0, rdx, 0, Secret, mask_b, 0);
        Pxor(xmm2, xmm0);
        Add64(r8, r9);
        Store128_buffer(r8, xmm2, 0, Secret, cipher_b, offset);
}

procedure {:quick} reverse_bytes_quad32_buffer(ghost b:buffer128)
    requires
        valid_taint_buf128(b, mem, memTaint, Secret);
        buffer_readable(mem, b);
        rdi == buffer_addr(b, mem);
        buffer_length(b) == 1;
    ensures
        rbx == old(rbx);
        rbp == old(rbp);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);
        r15 == old(r15);

        modifies_buffer128(b, old(mem), mem);
        buffer128_read(b, 0, mem) == reverse_bytes_quad32(buffer128_read(b, 0, old(mem)));
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
        Load128_buffer(xmm0, rdi, 0, Secret, b, 0);
        InitPshufbMask(xmm1, rax);
        Pshufb(xmm0, xmm1);
        Store128_buffer(rdi, xmm0, 0, Secret, b, 0);
}

procedure {:quick} reverse_bytes_quad32_buffer_win(ghost stack_b:buffer64, ghost b:buffer128)
    requires
        valid_taint_buf128(b, mem, memTaint, Secret);
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(b)));
        buffer_readable(mem, stack_b);
        buffer_readable(mem, b);
        buffer_length(stack_b) >= 2;
        valid_stack_slots(mem, rsp, stack_b, 0, memTaint);
        rcx == buffer_addr(b, mem);
        buffer_length(b) == 1;
    ensures
        rbx == old(rbx);
        rbp == old(rbp);
        rdi == old(rdi);
        rsi == old(rsi);
        rsp == old(rsp);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);
        r15 == old(r15);
        xmm6 == old(xmm6);
        xmm7 == old(xmm7);
        xmm8 == old(xmm8);
        xmm9 == old(xmm9);
        xmm10 == old(xmm10);
        xmm11 == old(xmm11);
        xmm12 == old(xmm12);
        xmm13 == old(xmm13);
        xmm14 == old(xmm14);
        xmm15 == old(xmm15);

        modifies_buffer128(b, old(mem), mem);
        buffer128_read(b, 0, mem) == reverse_bytes_quad32(buffer128_read(b, 0, old(mem)));
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
        Load128_buffer(xmm0, rcx, 0, Secret, b, 0);
        InitPshufbMask(xmm1, rax);
        Pshufb(xmm0, xmm1);
        Store128_buffer(rcx, xmm0, 0, Secret, b, 0);
}

include "X64.Vale.InsBasic.vaf"

module X64.Vale.InsMem

#verbatim{:interface}
open Types_s
open X64.Machine_s
open X64.Memory
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.QuickCode
open X64.Vale.InsBasic
#endverbatim

#verbatim
open X64.Machine_s
open X64.Memory
open X64.Vale
open X64.Vale.State
open X64.Vale.StateLemmas
open X64.Vale.Decls
open X64.Vale.InsBasic
module S = X64.Bytes_Semantics_s
module TS = X64.Taint_Semantics_s
module P = X64.Print_s
open X64.Taint_Semantics
#endverbatim

#reset-options "--initial_fuel 2 --max_fuel 4 --max_ifuel 2 --z3rlimit 20"

procedure{:operand} Mem_in(base:opr, inline offset:int, ghost b:buffer64, ghost index:int, inline t:taint) returns(o:opr)
    reads
        mem;
    extern;

procedure{:instruction mk_taint_ins2(S.Mov64, dst, TMem(MReg(get_reg(src), offset), t),
                                     list(dst), list(TMem(MReg(get_reg(src), offset), t)))}
         {:fast_instruction}{:quick exportOnly}
    Load64_buffer(
    out dst: dst_opr64,
        src:reg_opr64,
        inline offset:int,
        inline t:taint,
        ghost b:buffer64,
        ghost index:int)
    reads
        mem; memTaint;
    modifies

    requires
        valid_src_addr(mem, b, index);
        valid_taint_buf64(b, mem, memTaint, t);
        src + offset == buffer_addr(b, mem) + 8 * index;
    ensures
        dst == buffer64_read(b, index, mem);
        valid_taint_buf64(b, mem, memTaint, t);
{
    lemma_valid_mem64(b, index, mem);
    lemma_load_mem64(b, index, mem);
    lemma_valid_taint64(b, memTaint, mem, index, t);
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.Mov64(OMem(MReg(get_reg(dst), offset)), t_op_to_op(src)),
                                         list(OMem(MReg(get_reg(dst), offset))), list(t_op_to_op(src))), t))}
         {:fast_instruction}{:quick exportOnly}
    Store64_buffer(
        dst:reg_opr64,
        src: reg_opr64,
        inline offset:int,
        inline t:taint,
        ghost b:buffer64,
        ghost index:int)
    reads memTaint;
    modifies
        mem;
    requires
        valid_dst_addr(mem, b, index);
        valid_taint_buf64(b, mem, memTaint, t);
        dst + offset == buffer_addr(b, mem) + 8 * index;
    ensures
        modifies_mem(loc_buffer(b), old(mem), mem);
        mem == old(buffer64_write(b, index, src, mem));
        valid_taint_buf64(b, mem, memTaint, t);
{
    lemma_valid_mem64(b, index, old(mem));
    lemma_store_mem64(b, index, old(src), old(mem));
    lemma_valid_taint64(b, old(memTaint), old(mem), index, t);
    same_memTaint64(b, old(mem), mem, old(memTaint), memTaint);
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.Pop(t_op_to_op(dst)), list(t_op_to_op(dst)), list(OMem(MReg(Rsp, 0)))), Public))}
         {:fast_instruction}{:quick exportOnly}
    Pop(
    out dst: dst_opr64,
        ghost b:buffer64,
        ghost index:int)
    reads mem; memTaint;
    modifies rsp;
    requires
        valid_src_addr(mem, b, index);
        rsp == buffer_addr(b, mem) + 8 * index;
        rsp + 8 < pow2_64;
        valid_taint_buf64(b, mem, memTaint, Public);
    ensures
        dst == buffer64_read(b, index, mem);
        rsp == old(rsp) + 8;
{
    lemma_valid_mem64(b, index, mem);
    lemma_load_mem64(b, index, mem);
    lemma_valid_taint64(b, old(memTaint), old(mem), index, Public);
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.Push(t_op_to_op(src)), list(), list(t_op_to_op(src))), Public))}
         {:fast_instruction}{:quick exportOnly}
    Push(
        src: reg_opr64,
        ghost b:buffer64,
        ghost index:int)
    reads memTaint;
    modifies
        rsp; mem;
    requires
        valid_taint_buf64(b, mem, memTaint, Public);
        valid_dst_addr(mem, b, index);
        rsp - 8 == buffer_addr(b, mem) + 8 * index;
        0 <= rsp - 8;
    ensures
        modifies_mem(loc_buffer(b), old(mem), mem);
        mem == old(buffer64_write(b, index, src, mem));
        rsp == old(rsp) - 8;
{
    lemma_valid_mem64(b, index, old(mem));
    lemma_store_mem64(b, index, old(src), old(mem));
    lemma_valid_taint64(b, old(memTaint), old(mem), index, Public);
    same_memTaint64(b, old(mem), mem, old(memTaint), memTaint);
}

